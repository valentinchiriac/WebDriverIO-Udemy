const Ot = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), b = "ï¿½";
var r;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(r || (r = {}));
const S = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function Ye(e) {
  return e >= 55296 && e <= 57343;
}
function St(e) {
  return e >= 56320 && e <= 57343;
}
function Lt(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function ve(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function Qe(e) {
  return e >= 64976 && e <= 65007 || Ot.has(e);
}
var E;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(E || (E = {}));
const Rt = 65536;
class Dt {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = Rt, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t, a) {
    const { line: s, col: c, offset: d } = this, h = c + a, f = d + a;
    return {
      code: t,
      startLine: s,
      endLine: s,
      startCol: h,
      endCol: h,
      startOffset: f,
      endOffset: f
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const a = this.html.charCodeAt(this.pos + 1);
      if (St(a))
        return this.pos++, this._addGap(), Lt(t, a);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, r.EOF;
    return this._err(E.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, a) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = a;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, a) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (a)
      return this.html.startsWith(t, this.pos);
    for (let s = 0; s < t.length; s++)
      if ((this.html.charCodeAt(this.pos + s) | 32) !== t.charCodeAt(s))
        return !1;
    return !0;
  }
  peek(t) {
    const a = this.pos + t;
    if (a >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, r.EOF;
    const s = this.html.charCodeAt(a);
    return s === r.CARRIAGE_RETURN ? r.LINE_FEED : s;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, r.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === r.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, r.LINE_FEED) : t === r.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, Ye(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === r.LINE_FEED || t === r.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    ve(t) ? this._err(E.controlCharacterInInputStream) : Qe(t) && this._err(E.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var m;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(m || (m = {}));
function We(e, t) {
  for (let a = e.attrs.length - 1; a >= 0; a--)
    if (e.attrs[a].name === t)
      return e.attrs[a].value;
  return null;
}
const pt = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ 'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((e) => e.charCodeAt(0))
), gt = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
function Pt(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = gt.get(e)) !== null && t !== void 0 ? t : e;
}
var I;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(I || (I = {}));
const Mt = 32;
var H;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(H || (H = {}));
function Te(e) {
  return e >= I.ZERO && e <= I.NINE;
}
function Bt(e) {
  return e >= I.UPPER_A && e <= I.UPPER_F || e >= I.LOWER_A && e <= I.LOWER_F;
}
function xt(e) {
  return e >= I.UPPER_A && e <= I.UPPER_Z || e >= I.LOWER_A && e <= I.LOWER_Z || Te(e);
}
function Ht(e) {
  return e === I.EQUALS || xt(e);
}
var N;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(N || (N = {}));
var P;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(P || (P = {}));
class kt {
  constructor(t, a, s) {
    this.decodeTree = t, this.emitCodePoint = a, this.errors = s, this.state = N.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = P.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = N.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, a) {
    switch (this.state) {
      case N.EntityStart:
        return t.charCodeAt(a) === I.NUM ? (this.state = N.NumericStart, this.consumed += 1, this.stateNumericStart(t, a + 1)) : (this.state = N.NamedEntity, this.stateNamedEntity(t, a));
      case N.NumericStart:
        return this.stateNumericStart(t, a);
      case N.NumericDecimal:
        return this.stateNumericDecimal(t, a);
      case N.NumericHex:
        return this.stateNumericHex(t, a);
      case N.NamedEntity:
        return this.stateNamedEntity(t, a);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, a) {
    return a >= t.length ? -1 : (t.charCodeAt(a) | Mt) === I.LOWER_X ? (this.state = N.NumericHex, this.consumed += 1, this.stateNumericHex(t, a + 1)) : (this.state = N.NumericDecimal, this.stateNumericDecimal(t, a));
  }
  addToNumericResult(t, a, s, c) {
    if (a !== s) {
      const d = s - a;
      this.result = this.result * Math.pow(c, d) + Number.parseInt(t.substr(a, d), c), this.consumed += d;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, a) {
    const s = a;
    for (; a < t.length; ) {
      const c = t.charCodeAt(a);
      if (Te(c) || Bt(c))
        a += 1;
      else
        return this.addToNumericResult(t, s, a, 16), this.emitNumericEntity(c, 3);
    }
    return this.addToNumericResult(t, s, a, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, a) {
    const s = a;
    for (; a < t.length; ) {
      const c = t.charCodeAt(a);
      if (Te(c))
        a += 1;
      else
        return this.addToNumericResult(t, s, a, 10), this.emitNumericEntity(c, 2);
    }
    return this.addToNumericResult(t, s, a, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, a) {
    var s;
    if (this.consumed <= a)
      return (s = this.errors) === null || s === void 0 || s.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === I.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === P.Strict)
      return 0;
    return this.emitCodePoint(Pt(this.result), this.consumed), this.errors && (t !== I.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, a) {
    const { decodeTree: s } = this;
    let c = s[this.treeIndex], d = (c & H.VALUE_LENGTH) >> 14;
    for (; a < t.length; a++, this.excess++) {
      const h = t.charCodeAt(a);
      if (this.treeIndex = Ft(s, c, this.treeIndex + Math.max(1, d), h), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === P.Attribute && // We shouldn't have consumed any characters after the entity,
        (d === 0 || // And there should be no invalid characters.
        Ht(h)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (c = s[this.treeIndex], d = (c & H.VALUE_LENGTH) >> 14, d !== 0) {
        if (h === I.SEMI)
          return this.emitNamedEntityData(this.treeIndex, d, this.consumed + this.excess);
        this.decodeMode !== P.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: a, decodeTree: s } = this, c = (s[a] & H.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(a, c, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, a, s) {
    const { decodeTree: c } = this;
    return this.emitCodePoint(a === 1 ? c[t] & ~H.VALUE_LENGTH : c[t + 1], s), a === 3 && this.emitCodePoint(c[t + 2], s), s;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case N.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== P.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case N.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case N.NumericHex:
        return this.emitNumericEntity(0, 3);
      case N.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case N.EntityStart:
        return 0;
    }
  }
}
function Ft(e, t, a, s) {
  const c = (t & H.BRANCH_LENGTH) >> 7, d = t & H.JUMP_TABLE;
  if (c === 0)
    return d !== 0 && s === d ? a : -1;
  if (d) {
    const _ = s - d;
    return _ < 0 || _ >= c ? -1 : e[a + _] - 1;
  }
  let h = a, f = h + c - 1;
  for (; h <= f; ) {
    const _ = h + f >>> 1, A = e[_];
    if (A < s)
      h = _ + 1;
    else if (A > s)
      f = _ - 1;
    else
      return e[_ + c];
  }
  return -1;
}
var T;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(T || (T = {}));
var k;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(k || (k = {}));
var D;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(D || (D = {}));
var o;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SEARCH = "search", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(o || (o = {}));
var u;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SEARCH = 94] = "SEARCH", e[e.SECTION = 95] = "SECTION", e[e.SELECT = 96] = "SELECT", e[e.SOURCE = 97] = "SOURCE", e[e.SMALL = 98] = "SMALL", e[e.SPAN = 99] = "SPAN", e[e.STRIKE = 100] = "STRIKE", e[e.STRONG = 101] = "STRONG", e[e.STYLE = 102] = "STYLE", e[e.SUB = 103] = "SUB", e[e.SUMMARY = 104] = "SUMMARY", e[e.SUP = 105] = "SUP", e[e.TABLE = 106] = "TABLE", e[e.TBODY = 107] = "TBODY", e[e.TEMPLATE = 108] = "TEMPLATE", e[e.TEXTAREA = 109] = "TEXTAREA", e[e.TFOOT = 110] = "TFOOT", e[e.TD = 111] = "TD", e[e.TH = 112] = "TH", e[e.THEAD = 113] = "THEAD", e[e.TITLE = 114] = "TITLE", e[e.TR = 115] = "TR", e[e.TRACK = 116] = "TRACK", e[e.TT = 117] = "TT", e[e.U = 118] = "U", e[e.UL = 119] = "UL", e[e.SVG = 120] = "SVG", e[e.VAR = 121] = "VAR", e[e.WBR = 122] = "WBR", e[e.XMP = 123] = "XMP";
})(u || (u = {}));
const Ut = /* @__PURE__ */ new Map([
  [o.A, u.A],
  [o.ADDRESS, u.ADDRESS],
  [o.ANNOTATION_XML, u.ANNOTATION_XML],
  [o.APPLET, u.APPLET],
  [o.AREA, u.AREA],
  [o.ARTICLE, u.ARTICLE],
  [o.ASIDE, u.ASIDE],
  [o.B, u.B],
  [o.BASE, u.BASE],
  [o.BASEFONT, u.BASEFONT],
  [o.BGSOUND, u.BGSOUND],
  [o.BIG, u.BIG],
  [o.BLOCKQUOTE, u.BLOCKQUOTE],
  [o.BODY, u.BODY],
  [o.BR, u.BR],
  [o.BUTTON, u.BUTTON],
  [o.CAPTION, u.CAPTION],
  [o.CENTER, u.CENTER],
  [o.CODE, u.CODE],
  [o.COL, u.COL],
  [o.COLGROUP, u.COLGROUP],
  [o.DD, u.DD],
  [o.DESC, u.DESC],
  [o.DETAILS, u.DETAILS],
  [o.DIALOG, u.DIALOG],
  [o.DIR, u.DIR],
  [o.DIV, u.DIV],
  [o.DL, u.DL],
  [o.DT, u.DT],
  [o.EM, u.EM],
  [o.EMBED, u.EMBED],
  [o.FIELDSET, u.FIELDSET],
  [o.FIGCAPTION, u.FIGCAPTION],
  [o.FIGURE, u.FIGURE],
  [o.FONT, u.FONT],
  [o.FOOTER, u.FOOTER],
  [o.FOREIGN_OBJECT, u.FOREIGN_OBJECT],
  [o.FORM, u.FORM],
  [o.FRAME, u.FRAME],
  [o.FRAMESET, u.FRAMESET],
  [o.H1, u.H1],
  [o.H2, u.H2],
  [o.H3, u.H3],
  [o.H4, u.H4],
  [o.H5, u.H5],
  [o.H6, u.H6],
  [o.HEAD, u.HEAD],
  [o.HEADER, u.HEADER],
  [o.HGROUP, u.HGROUP],
  [o.HR, u.HR],
  [o.HTML, u.HTML],
  [o.I, u.I],
  [o.IMG, u.IMG],
  [o.IMAGE, u.IMAGE],
  [o.INPUT, u.INPUT],
  [o.IFRAME, u.IFRAME],
  [o.KEYGEN, u.KEYGEN],
  [o.LABEL, u.LABEL],
  [o.LI, u.LI],
  [o.LINK, u.LINK],
  [o.LISTING, u.LISTING],
  [o.MAIN, u.MAIN],
  [o.MALIGNMARK, u.MALIGNMARK],
  [o.MARQUEE, u.MARQUEE],
  [o.MATH, u.MATH],
  [o.MENU, u.MENU],
  [o.META, u.META],
  [o.MGLYPH, u.MGLYPH],
  [o.MI, u.MI],
  [o.MO, u.MO],
  [o.MN, u.MN],
  [o.MS, u.MS],
  [o.MTEXT, u.MTEXT],
  [o.NAV, u.NAV],
  [o.NOBR, u.NOBR],
  [o.NOFRAMES, u.NOFRAMES],
  [o.NOEMBED, u.NOEMBED],
  [o.NOSCRIPT, u.NOSCRIPT],
  [o.OBJECT, u.OBJECT],
  [o.OL, u.OL],
  [o.OPTGROUP, u.OPTGROUP],
  [o.OPTION, u.OPTION],
  [o.P, u.P],
  [o.PARAM, u.PARAM],
  [o.PLAINTEXT, u.PLAINTEXT],
  [o.PRE, u.PRE],
  [o.RB, u.RB],
  [o.RP, u.RP],
  [o.RT, u.RT],
  [o.RTC, u.RTC],
  [o.RUBY, u.RUBY],
  [o.S, u.S],
  [o.SCRIPT, u.SCRIPT],
  [o.SEARCH, u.SEARCH],
  [o.SECTION, u.SECTION],
  [o.SELECT, u.SELECT],
  [o.SOURCE, u.SOURCE],
  [o.SMALL, u.SMALL],
  [o.SPAN, u.SPAN],
  [o.STRIKE, u.STRIKE],
  [o.STRONG, u.STRONG],
  [o.STYLE, u.STYLE],
  [o.SUB, u.SUB],
  [o.SUMMARY, u.SUMMARY],
  [o.SUP, u.SUP],
  [o.TABLE, u.TABLE],
  [o.TBODY, u.TBODY],
  [o.TEMPLATE, u.TEMPLATE],
  [o.TEXTAREA, u.TEXTAREA],
  [o.TFOOT, u.TFOOT],
  [o.TD, u.TD],
  [o.TH, u.TH],
  [o.THEAD, u.THEAD],
  [o.TITLE, u.TITLE],
  [o.TR, u.TR],
  [o.TRACK, u.TRACK],
  [o.TT, u.TT],
  [o.U, u.U],
  [o.UL, u.UL],
  [o.SVG, u.SVG],
  [o.VAR, u.VAR],
  [o.WBR, u.WBR],
  [o.XMP, u.XMP]
]);
function re(e) {
  var t;
  return (t = Ut.get(e)) !== null && t !== void 0 ? t : u.UNKNOWN;
}
const l = u, yt = {
  [T.HTML]: /* @__PURE__ */ new Set([
    l.ADDRESS,
    l.APPLET,
    l.AREA,
    l.ARTICLE,
    l.ASIDE,
    l.BASE,
    l.BASEFONT,
    l.BGSOUND,
    l.BLOCKQUOTE,
    l.BODY,
    l.BR,
    l.BUTTON,
    l.CAPTION,
    l.CENTER,
    l.COL,
    l.COLGROUP,
    l.DD,
    l.DETAILS,
    l.DIR,
    l.DIV,
    l.DL,
    l.DT,
    l.EMBED,
    l.FIELDSET,
    l.FIGCAPTION,
    l.FIGURE,
    l.FOOTER,
    l.FORM,
    l.FRAME,
    l.FRAMESET,
    l.H1,
    l.H2,
    l.H3,
    l.H4,
    l.H5,
    l.H6,
    l.HEAD,
    l.HEADER,
    l.HGROUP,
    l.HR,
    l.HTML,
    l.IFRAME,
    l.IMG,
    l.INPUT,
    l.LI,
    l.LINK,
    l.LISTING,
    l.MAIN,
    l.MARQUEE,
    l.MENU,
    l.META,
    l.NAV,
    l.NOEMBED,
    l.NOFRAMES,
    l.NOSCRIPT,
    l.OBJECT,
    l.OL,
    l.P,
    l.PARAM,
    l.PLAINTEXT,
    l.PRE,
    l.SCRIPT,
    l.SECTION,
    l.SELECT,
    l.SOURCE,
    l.STYLE,
    l.SUMMARY,
    l.TABLE,
    l.TBODY,
    l.TD,
    l.TEMPLATE,
    l.TEXTAREA,
    l.TFOOT,
    l.TH,
    l.THEAD,
    l.TITLE,
    l.TR,
    l.TRACK,
    l.UL,
    l.WBR,
    l.XMP
  ]),
  [T.MATHML]: /* @__PURE__ */ new Set([l.MI, l.MO, l.MN, l.MS, l.MTEXT, l.ANNOTATION_XML]),
  [T.SVG]: /* @__PURE__ */ new Set([l.TITLE, l.FOREIGN_OBJECT, l.DESC]),
  [T.XLINK]: /* @__PURE__ */ new Set(),
  [T.XML]: /* @__PURE__ */ new Set(),
  [T.XMLNS]: /* @__PURE__ */ new Set()
}, he = /* @__PURE__ */ new Set([l.H1, l.H2, l.H3, l.H4, l.H5, l.H6]);
o.STYLE, o.SCRIPT, o.XMP, o.IFRAME, o.NOEMBED, o.NOFRAMES, o.PLAINTEXT;
var i;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(i || (i = {}));
const L = {
  DATA: i.DATA,
  RCDATA: i.RCDATA,
  RAWTEXT: i.RAWTEXT,
  SCRIPT_DATA: i.SCRIPT_DATA,
  PLAINTEXT: i.PLAINTEXT,
  CDATA_SECTION: i.CDATA_SECTION
};
function wt(e) {
  return e >= r.DIGIT_0 && e <= r.DIGIT_9;
}
function v(e) {
  return e >= r.LATIN_CAPITAL_A && e <= r.LATIN_CAPITAL_Z;
}
function Yt(e) {
  return e >= r.LATIN_SMALL_A && e <= r.LATIN_SMALL_Z;
}
function M(e) {
  return Yt(e) || v(e);
}
function Re(e) {
  return M(e) || wt(e);
}
function J(e) {
  return e + 32;
}
function Ge(e) {
  return e === r.SPACE || e === r.LINE_FEED || e === r.TABULATION || e === r.FORM_FEED;
}
function De(e) {
  return Ge(e) || e === r.SOLIDUS || e === r.GREATER_THAN_SIGN;
}
function vt(e) {
  return e === r.NULL ? E.nullCharacterReference : e > 1114111 ? E.characterReferenceOutsideUnicodeRange : Ye(e) ? E.surrogateCharacterReference : Qe(e) ? E.noncharacterCharacterReference : ve(e) || e === r.CARRIAGE_RETURN ? E.controlCharacterReference : null;
}
class Qt {
  constructor(t, a) {
    this.options = t, this.handler = a, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = i.DATA, this.returnState = i.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new Dt(a), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new kt(pt, (s, c) => {
      this.preprocessor.pos = this.entityStartPos + c - 1, this._flushCodePointConsumedAsCharacterReference(s);
    }, a.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(E.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (s) => {
        this._err(E.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + s);
      },
      validateNumericCharacterReference: (s) => {
        const c = vt(s);
        c && this._err(c, 1);
      }
    } : void 0);
  }
  //Errors
  _err(t, a = 0) {
    var s, c;
    (c = (s = this.handler).onParseError) === null || c === void 0 || c.call(s, this.preprocessor.getError(t, a));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t?.());
  }
  write(t, a, s) {
    this.active = !0, this.preprocessor.write(t, a), this._runParsingLoop(), this.paused || s?.();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let a = 0; a < t; a++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, a) {
    return this.preprocessor.startsWith(t, a) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: m.START_TAG,
      tagName: "",
      tagID: u.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: m.END_TAG,
      tagName: "",
      tagID: u.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: m.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: m.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, a) {
    this.currentCharacterToken = {
      type: t,
      chars: a,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, a;
    const s = this.currentToken;
    if (We(s, this.currentAttr.name) === null) {
      if (s.attrs.push(this.currentAttr), s.location && this.currentLocation) {
        const c = (t = (a = s.location).attrs) !== null && t !== void 0 ? t : a.attrs = /* @__PURE__ */ Object.create(null);
        c[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(E.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = re(t.tagName), t.type === m.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(E.endTagWithAttributes), t.selfClosing && this._err(E.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case m.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case m.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case m.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: m.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, a) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === t) {
        this.currentCharacterToken.chars += a;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(t, a);
  }
  _emitCodePoint(t) {
    const a = Ge(t) ? m.WHITESPACE_CHARACTER : t === r.NULL ? m.NULL_CHARACTER : m.CHARACTER;
    this._appendCharToCurrentCharacterToken(a, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(m.CHARACTER, t);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = i.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? P.Attribute : P.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === i.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === i.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === i.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case i.DATA: {
        this._stateData(t);
        break;
      }
      case i.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case i.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case i.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case i.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case i.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case i.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case i.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case i.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case i.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case i.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case i.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case i.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case i.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case i.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case i.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case i.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case i.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case i.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case i.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case i.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case i.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case i.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case i.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case i.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case i.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case i.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case i.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case i.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case i.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case i.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case i.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case i.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case i.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case i.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case i.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case i.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case i.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case i.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case i.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case i.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case i.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case i.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case i.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case i.COMMENT: {
        this._stateComment(t);
        break;
      }
      case i.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case i.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case i.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case i.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case i.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case i.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case i.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case i.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case i.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case i.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case i.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case i.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case i.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case i.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case i.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case i.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case i.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case i.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case i.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case i.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case i.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case i.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case i.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case i.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case i.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case i.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case i.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case i.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case r.LESS_THAN_SIGN: {
        this.state = i.TAG_OPEN;
        break;
      }
      case r.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case r.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case r.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case r.LESS_THAN_SIGN: {
        this.state = i.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case r.LESS_THAN_SIGN: {
        this.state = i.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case r.LESS_THAN_SIGN: {
        this.state = i.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (M(t))
      this._createStartTagToken(), this.state = i.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case r.EXCLAMATION_MARK: {
          this.state = i.MARKUP_DECLARATION_OPEN;
          break;
        }
        case r.SOLIDUS: {
          this.state = i.END_TAG_OPEN;
          break;
        }
        case r.QUESTION_MARK: {
          this._err(E.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = i.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case r.EOF: {
          this._err(E.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(E.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = i.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (M(t))
      this._createEndTagToken(), this.state = i.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case r.GREATER_THAN_SIGN: {
          this._err(E.missingEndTagName), this.state = i.DATA;
          break;
        }
        case r.EOF: {
          this._err(E.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(E.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = i.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED: {
        this.state = i.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case r.SOLIDUS: {
        this.state = i.SELF_CLOSING_START_TAG;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this.state = i.DATA, this.emitCurrentTagToken();
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), a.tagName += b;
        break;
      }
      case r.EOF: {
        this._err(E.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        a.tagName += String.fromCodePoint(v(t) ? J(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === r.SOLIDUS ? this.state = i.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = i.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    M(t) ? (this.state = i.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = i.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const a = this.currentToken;
    switch (a.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = i.BEFORE_ATTRIBUTE_NAME, !1;
      case r.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = i.SELF_CLOSING_START_TAG, !1;
      case r.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = i.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = i.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === r.SOLIDUS ? this.state = i.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = i.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    M(t) ? (this.state = i.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = i.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = i.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case r.SOLIDUS: {
        this.state = i.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case r.EXCLAMATION_MARK: {
        this.state = i.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = i.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    M(t) ? (this.state = i.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = i.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = i.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === r.HYPHEN_MINUS ? (this.state = i.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = i.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === r.HYPHEN_MINUS ? (this.state = i.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = i.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case r.HYPHEN_MINUS: {
        this.state = i.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case r.LESS_THAN_SIGN: {
        this.state = i.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._err(E.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case r.HYPHEN_MINUS: {
        this.state = i.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case r.LESS_THAN_SIGN: {
        this.state = i.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this.state = i.SCRIPT_DATA_ESCAPED, this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._err(E.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = i.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case r.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case r.LESS_THAN_SIGN: {
        this.state = i.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this.state = i.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this.state = i.SCRIPT_DATA_ESCAPED, this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._err(E.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = i.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === r.SOLIDUS ? this.state = i.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : M(t) ? (this._emitChars("<"), this.state = i.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = i.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    M(t) ? (this.state = i.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = i.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = i.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(S.SCRIPT, !1) && De(this.preprocessor.peek(S.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let a = 0; a < S.SCRIPT.length; a++)
        this._emitCodePoint(this._consume());
      this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = i.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case r.HYPHEN_MINUS: {
        this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case r.LESS_THAN_SIGN: {
        this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._err(E.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case r.HYPHEN_MINUS: {
        this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case r.LESS_THAN_SIGN: {
        this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._err(E.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case r.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case r.LESS_THAN_SIGN: {
        this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this.state = i.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(b);
        break;
      }
      case r.EOF: {
        this._err(E.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === r.SOLIDUS ? (this.state = i.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(S.SCRIPT, !1) && De(this.preprocessor.peek(S.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let a = 0; a < S.SCRIPT.length; a++)
        this._emitCodePoint(this._consume());
      this.state = i.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = i.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
        break;
      case r.SOLIDUS:
      case r.GREATER_THAN_SIGN:
      case r.EOF: {
        this.state = i.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case r.EQUALS_SIGN: {
        this._err(E.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = i.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = i.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
      case r.SOLIDUS:
      case r.GREATER_THAN_SIGN:
      case r.EOF: {
        this._leaveAttrName(), this.state = i.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case r.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = i.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case r.QUOTATION_MARK:
      case r.APOSTROPHE:
      case r.LESS_THAN_SIGN: {
        this._err(E.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this.currentAttr.name += b;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(v(t) ? J(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
        break;
      case r.SOLIDUS: {
        this.state = i.SELF_CLOSING_START_TAG;
        break;
      }
      case r.EQUALS_SIGN: {
        this.state = i.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this.state = i.DATA, this.emitCurrentTagToken();
        break;
      }
      case r.EOF: {
        this._err(E.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = i.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
        break;
      case r.QUOTATION_MARK: {
        this.state = i.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case r.APOSTROPHE: {
        this.state = i.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.missingAttributeValue), this.state = i.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = i.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case r.QUOTATION_MARK: {
        this.state = i.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case r.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this.currentAttr.value += b;
        break;
      }
      case r.EOF: {
        this._err(E.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case r.APOSTROPHE: {
        this.state = i.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case r.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this.currentAttr.value += b;
        break;
      }
      case r.EOF: {
        this._err(E.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED: {
        this._leaveAttrValue(), this.state = i.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case r.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = i.DATA, this.emitCurrentTagToken();
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), this.currentAttr.value += b;
        break;
      }
      case r.QUOTATION_MARK:
      case r.APOSTROPHE:
      case r.LESS_THAN_SIGN:
      case r.EQUALS_SIGN:
      case r.GRAVE_ACCENT: {
        this._err(E.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case r.EOF: {
        this._err(E.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED: {
        this._leaveAttrValue(), this.state = i.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case r.SOLIDUS: {
        this._leaveAttrValue(), this.state = i.SELF_CLOSING_START_TAG;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = i.DATA, this.emitCurrentTagToken();
        break;
      }
      case r.EOF: {
        this._err(E.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.missingWhitespaceBetweenAttributes), this.state = i.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case r.GREATER_THAN_SIGN: {
        const a = this.currentToken;
        a.selfClosing = !0, this.state = i.DATA, this.emitCurrentTagToken();
        break;
      }
      case r.EOF: {
        this._err(E.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.unexpectedSolidusInTag), this.state = i.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const a = this.currentToken;
    switch (t) {
      case r.GREATER_THAN_SIGN: {
        this.state = i.DATA, this.emitCurrentComment(a);
        break;
      }
      case r.EOF: {
        this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), a.data += b;
        break;
      }
      default:
        a.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(S.DASH_DASH, !0) ? (this._createCommentToken(S.DASH_DASH.length + 1), this.state = i.COMMENT_START) : this._consumeSequenceIfMatch(S.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(S.DOCTYPE.length + 1), this.state = i.DOCTYPE) : this._consumeSequenceIfMatch(S.CDATA_START, !0) ? this.inForeignNode ? this.state = i.CDATA_SECTION : (this._err(E.cdataInHtmlContent), this._createCommentToken(S.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = i.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(E.incorrectlyOpenedComment), this._createCommentToken(2), this.state = i.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case r.HYPHEN_MINUS: {
        this.state = i.COMMENT_START_DASH;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.abruptClosingOfEmptyComment), this.state = i.DATA;
        const a = this.currentToken;
        this.emitCurrentComment(a);
        break;
      }
      default:
        this.state = i.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const a = this.currentToken;
    switch (t) {
      case r.HYPHEN_MINUS: {
        this.state = i.COMMENT_END;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.abruptClosingOfEmptyComment), this.state = i.DATA, this.emitCurrentComment(a);
        break;
      }
      case r.EOF: {
        this._err(E.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "-", this.state = i.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const a = this.currentToken;
    switch (t) {
      case r.HYPHEN_MINUS: {
        this.state = i.COMMENT_END_DASH;
        break;
      }
      case r.LESS_THAN_SIGN: {
        a.data += "<", this.state = i.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), a.data += b;
        break;
      }
      case r.EOF: {
        this._err(E.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const a = this.currentToken;
    switch (t) {
      case r.EXCLAMATION_MARK: {
        a.data += "!", this.state = i.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case r.LESS_THAN_SIGN: {
        a.data += "<";
        break;
      }
      default:
        this.state = i.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === r.HYPHEN_MINUS ? this.state = i.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = i.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === r.HYPHEN_MINUS ? this.state = i.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = i.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== r.GREATER_THAN_SIGN && t !== r.EOF && this._err(E.nestedComment), this.state = i.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const a = this.currentToken;
    switch (t) {
      case r.HYPHEN_MINUS: {
        this.state = i.COMMENT_END;
        break;
      }
      case r.EOF: {
        this._err(E.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "-", this.state = i.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const a = this.currentToken;
    switch (t) {
      case r.GREATER_THAN_SIGN: {
        this.state = i.DATA, this.emitCurrentComment(a);
        break;
      }
      case r.EXCLAMATION_MARK: {
        this.state = i.COMMENT_END_BANG;
        break;
      }
      case r.HYPHEN_MINUS: {
        a.data += "-";
        break;
      }
      case r.EOF: {
        this._err(E.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "--", this.state = i.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const a = this.currentToken;
    switch (t) {
      case r.HYPHEN_MINUS: {
        a.data += "--!", this.state = i.COMMENT_END_DASH;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.incorrectlyClosedComment), this.state = i.DATA, this.emitCurrentComment(a);
        break;
      }
      case r.EOF: {
        this._err(E.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "--!", this.state = i.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED: {
        this.state = i.BEFORE_DOCTYPE_NAME;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this.state = i.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), this._createDoctypeToken(null);
        const a = this.currentToken;
        a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.missingWhitespaceBeforeDoctypeName), this.state = i.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (v(t))
      this._createDoctypeToken(String.fromCharCode(J(t))), this.state = i.DOCTYPE_NAME;
    else
      switch (t) {
        case r.SPACE:
        case r.LINE_FEED:
        case r.TABULATION:
        case r.FORM_FEED:
          break;
        case r.NULL: {
          this._err(E.unexpectedNullCharacter), this._createDoctypeToken(b), this.state = i.DOCTYPE_NAME;
          break;
        }
        case r.GREATER_THAN_SIGN: {
          this._err(E.missingDoctypeName), this._createDoctypeToken(null);
          const a = this.currentToken;
          a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = i.DATA;
          break;
        }
        case r.EOF: {
          this._err(E.eofInDoctype), this._createDoctypeToken(null);
          const a = this.currentToken;
          a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = i.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED: {
        this.state = i.AFTER_DOCTYPE_NAME;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this.state = i.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), a.name += b;
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.name += String.fromCodePoint(v(t) ? J(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
        break;
      case r.GREATER_THAN_SIGN: {
        this.state = i.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(S.PUBLIC, !1) ? this.state = i.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(S.SYSTEM, !1) ? this.state = i.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(E.invalidCharacterSequenceAfterDoctypeName), a.forceQuirks = !0, this.state = i.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED: {
        this.state = i.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case r.QUOTATION_MARK: {
        this._err(E.missingWhitespaceAfterDoctypePublicKeyword), a.publicId = "", this.state = i.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case r.APOSTROPHE: {
        this._err(E.missingWhitespaceAfterDoctypePublicKeyword), a.publicId = "", this.state = i.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.missingDoctypePublicIdentifier), a.forceQuirks = !0, this.state = i.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.missingQuoteBeforeDoctypePublicIdentifier), a.forceQuirks = !0, this.state = i.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
        break;
      case r.QUOTATION_MARK: {
        a.publicId = "", this.state = i.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case r.APOSTROPHE: {
        a.publicId = "", this.state = i.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.missingDoctypePublicIdentifier), a.forceQuirks = !0, this.state = i.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.missingQuoteBeforeDoctypePublicIdentifier), a.forceQuirks = !0, this.state = i.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case r.QUOTATION_MARK: {
        this.state = i.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), a.publicId += b;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.abruptDoctypePublicIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = i.DATA;
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case r.APOSTROPHE: {
        this.state = i.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), a.publicId += b;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.abruptDoctypePublicIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = i.DATA;
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED: {
        this.state = i.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this.state = i.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case r.QUOTATION_MARK: {
        this._err(E.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), a.systemId = "", this.state = i.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case r.APOSTROPHE: {
        this._err(E.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), a.systemId = "", this.state = i.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = i.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
        break;
      case r.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(a), this.state = i.DATA;
        break;
      }
      case r.QUOTATION_MARK: {
        a.systemId = "", this.state = i.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case r.APOSTROPHE: {
        a.systemId = "", this.state = i.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = i.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED: {
        this.state = i.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case r.QUOTATION_MARK: {
        this._err(E.missingWhitespaceAfterDoctypeSystemKeyword), a.systemId = "", this.state = i.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case r.APOSTROPHE: {
        this._err(E.missingWhitespaceAfterDoctypeSystemKeyword), a.systemId = "", this.state = i.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.missingDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = i.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = i.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
        break;
      case r.QUOTATION_MARK: {
        a.systemId = "", this.state = i.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case r.APOSTROPHE: {
        a.systemId = "", this.state = i.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.missingDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = i.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = i.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case r.QUOTATION_MARK: {
        this.state = i.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), a.systemId += b;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.abruptDoctypeSystemIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = i.DATA;
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case r.APOSTROPHE: {
        this.state = i.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter), a.systemId += b;
        break;
      }
      case r.GREATER_THAN_SIGN: {
        this._err(E.abruptDoctypeSystemIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = i.DATA;
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case r.SPACE:
      case r.LINE_FEED:
      case r.TABULATION:
      case r.FORM_FEED:
        break;
      case r.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(a), this.state = i.DATA;
        break;
      }
      case r.EOF: {
        this._err(E.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(E.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = i.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const a = this.currentToken;
    switch (t) {
      case r.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(a), this.state = i.DATA;
        break;
      }
      case r.NULL: {
        this._err(E.unexpectedNullCharacter);
        break;
      }
      case r.EOF: {
        this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case r.RIGHT_SQUARE_BRACKET: {
        this.state = i.CDATA_SECTION_BRACKET;
        break;
      }
      case r.EOF: {
        this._err(E.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === r.RIGHT_SQUARE_BRACKET ? this.state = i.CDATA_SECTION_END : (this._emitChars("]"), this.state = i.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case r.GREATER_THAN_SIGN: {
        this.state = i.DATA;
        break;
      }
      case r.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = i.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (t < 0)
      if (this.preprocessor.lastChunkWritten)
        t = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    t === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(r.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && Re(this.preprocessor.peek(1)) ? i.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    Re(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === r.SEMICOLON && this._err(E.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t));
  }
}
const qe = /* @__PURE__ */ new Set([u.DD, u.DT, u.LI, u.OPTGROUP, u.OPTION, u.P, u.RB, u.RP, u.RT, u.RTC]), pe = /* @__PURE__ */ new Set([
  ...qe,
  u.CAPTION,
  u.COLGROUP,
  u.TBODY,
  u.TD,
  u.TFOOT,
  u.TH,
  u.THEAD,
  u.TR
]), te = /* @__PURE__ */ new Set([
  u.APPLET,
  u.CAPTION,
  u.HTML,
  u.MARQUEE,
  u.OBJECT,
  u.TABLE,
  u.TD,
  u.TEMPLATE,
  u.TH
]), Wt = /* @__PURE__ */ new Set([...te, u.OL, u.UL]), Gt = /* @__PURE__ */ new Set([...te, u.BUTTON]), ge = /* @__PURE__ */ new Set([u.ANNOTATION_XML, u.MI, u.MN, u.MO, u.MS, u.MTEXT]), Pe = /* @__PURE__ */ new Set([u.DESC, u.FOREIGN_OBJECT, u.TITLE]), qt = /* @__PURE__ */ new Set([u.TR, u.TEMPLATE, u.HTML]), Kt = /* @__PURE__ */ new Set([u.TBODY, u.TFOOT, u.THEAD, u.TEMPLATE, u.HTML]), Xt = /* @__PURE__ */ new Set([u.TABLE, u.TEMPLATE, u.HTML]), Vt = /* @__PURE__ */ new Set([u.TD, u.TH]);
class zt {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, a, s) {
    this.treeAdapter = a, this.handler = s, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = u.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === u.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === T.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, a) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = a, this.currentTagId = a, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, a, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, a) {
    const s = this._indexOf(t);
    this.items[s] = a, s === this.stackTop && (this.current = a);
  }
  insertAfter(t, a, s) {
    const c = this._indexOf(t) + 1;
    this.items.splice(c, 0, a), this.tagIDs.splice(c, 0, s), this.stackTop++, c === this.stackTop && this._updateCurrentElement(), this.current && this.currentTagId !== void 0 && this.handler.onItemPush(this.current, this.currentTagId, c === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let a = this.stackTop + 1;
    do
      a = this.tagIDs.lastIndexOf(t, a - 1);
    while (a > 0 && this.treeAdapter.getNamespaceURI(this.items[a]) !== T.HTML);
    this.shortenToLength(Math.max(a, 0));
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const a = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(a, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const a = this._indexOf(t);
    this.shortenToLength(Math.max(a, 0));
  }
  popUntilPopped(t, a) {
    const s = this._indexOfTagNames(t, a);
    this.shortenToLength(Math.max(s, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(he, T.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(Vt, T.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, a) {
    for (let s = this.stackTop; s >= 0; s--)
      if (t.has(this.tagIDs[s]) && this.treeAdapter.getNamespaceURI(this.items[s]) === a)
        return s;
    return -1;
  }
  clearBackTo(t, a) {
    const s = this._indexOfTagNames(t, a);
    this.shortenToLength(s + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(Xt, T.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(Kt, T.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(qt, T.HTML);
  }
  remove(t) {
    const a = this._indexOf(t);
    a >= 0 && (a === this.stackTop ? this.pop() : (this.items.splice(a, 1), this.tagIDs.splice(a, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === u.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const a = this._indexOf(t) - 1;
    return a >= 0 ? this.items[a] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === u.HTML;
  }
  //Element in scope
  hasInDynamicScope(t, a) {
    for (let s = this.stackTop; s >= 0; s--) {
      const c = this.tagIDs[s];
      switch (this.treeAdapter.getNamespaceURI(this.items[s])) {
        case T.HTML: {
          if (c === t)
            return !0;
          if (a.has(c))
            return !1;
          break;
        }
        case T.SVG: {
          if (Pe.has(c))
            return !1;
          break;
        }
        case T.MATHML: {
          if (ge.has(c))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(t) {
    return this.hasInDynamicScope(t, te);
  }
  hasInListItemScope(t) {
    return this.hasInDynamicScope(t, Wt);
  }
  hasInButtonScope(t) {
    return this.hasInDynamicScope(t, Gt);
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const a = this.tagIDs[t];
      switch (this.treeAdapter.getNamespaceURI(this.items[t])) {
        case T.HTML: {
          if (he.has(a))
            return !0;
          if (te.has(a))
            return !1;
          break;
        }
        case T.SVG: {
          if (Pe.has(a))
            return !1;
          break;
        }
        case T.MATHML: {
          if (ge.has(a))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let a = this.stackTop; a >= 0; a--)
      if (this.treeAdapter.getNamespaceURI(this.items[a]) === T.HTML)
        switch (this.tagIDs[a]) {
          case t:
            return !0;
          case u.TABLE:
          case u.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--)
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === T.HTML)
        switch (this.tagIDs[t]) {
          case u.TBODY:
          case u.THEAD:
          case u.TFOOT:
            return !0;
          case u.TABLE:
          case u.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(t) {
    for (let a = this.stackTop; a >= 0; a--)
      if (this.treeAdapter.getNamespaceURI(this.items[a]) === T.HTML)
        switch (this.tagIDs[a]) {
          case t:
            return !0;
          case u.OPTION:
          case u.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; this.currentTagId !== void 0 && qe.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; this.currentTagId !== void 0 && pe.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== void 0 && this.currentTagId !== t && pe.has(this.currentTagId); )
      this.pop();
  }
}
const de = 3;
var g;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(g || (g = {}));
const Me = { type: g.Marker };
class jt {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, a) {
    const s = [], c = a.length, d = this.treeAdapter.getTagName(t), h = this.treeAdapter.getNamespaceURI(t);
    for (let f = 0; f < this.entries.length; f++) {
      const _ = this.entries[f];
      if (_.type === g.Marker)
        break;
      const { element: A } = _;
      if (this.treeAdapter.getTagName(A) === d && this.treeAdapter.getNamespaceURI(A) === h) {
        const O = this.treeAdapter.getAttrList(A);
        O.length === c && s.push({ idx: f, attrs: O });
      }
    }
    return s;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < de)
      return;
    const a = this.treeAdapter.getAttrList(t), s = this._getNoahArkConditionCandidates(t, a);
    if (s.length < de)
      return;
    const c = new Map(a.map((h) => [h.name, h.value]));
    let d = 0;
    for (let h = 0; h < s.length; h++) {
      const f = s[h];
      f.attrs.every((_) => c.get(_.name) === _.value) && (d += 1, d >= de && this.entries.splice(f.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Me);
  }
  pushElement(t, a) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: g.Element,
      element: t,
      token: a
    });
  }
  insertElementAfterBookmark(t, a) {
    const s = this.entries.indexOf(this.bookmark);
    this.entries.splice(s, 0, {
      type: g.Element,
      element: t,
      token: a
    });
  }
  removeEntry(t) {
    const a = this.entries.indexOf(t);
    a !== -1 && this.entries.splice(a, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(Me);
    t === -1 ? this.entries.length = 0 : this.entries.splice(0, t + 1);
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const a = this.entries.find((s) => s.type === g.Marker || this.treeAdapter.getTagName(s.element) === t);
    return a && a.type === g.Element ? a : null;
  }
  getElementEntry(t) {
    return this.entries.find((a) => a.type === g.Element && a.element === t);
  }
}
const B = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: D.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, a) {
    return {
      nodeName: e,
      tagName: e,
      attrs: a,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  createTextNode(e) {
    return {
      nodeName: "#text",
      value: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, a) {
    const s = e.childNodes.indexOf(a);
    e.childNodes.splice(s, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, a, s) {
    const c = e.childNodes.find((d) => d.nodeName === "#documentType");
    if (c)
      c.name = t, c.publicId = a, c.systemId = s;
    else {
      const d = {
        nodeName: "#documentType",
        name: t,
        publicId: a,
        systemId: s,
        parentNode: null
      };
      B.appendChild(e, d);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const a = e.childNodes[e.childNodes.length - 1];
      if (B.isTextNode(a)) {
        a.value += t;
        return;
      }
    }
    B.appendChild(e, B.createTextNode(t));
  },
  insertTextBefore(e, t, a) {
    const s = e.childNodes[e.childNodes.indexOf(a) - 1];
    s && B.isTextNode(s) ? s.value += t : B.insertBefore(e, B.createTextNode(t), a);
  },
  adoptAttributes(e, t) {
    const a = new Set(e.attrs.map((s) => s.name));
    for (let s = 0; s < t.length; s++)
      a.has(t[s].name) || e.attrs.push(t[s]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, Ke = "html", Jt = "about:legacy-compat", Zt = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", Xe = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], $t = [
  ...Xe,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], eu = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), Ve = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], tu = [
  ...Ve,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function Be(e, t) {
  return t.some((a) => e.startsWith(a));
}
function uu(e) {
  return e.name === Ke && e.publicId === null && (e.systemId === null || e.systemId === Jt);
}
function au(e) {
  if (e.name !== Ke)
    return D.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === Zt)
    return D.QUIRKS;
  let { publicId: a } = e;
  if (a !== null) {
    if (a = a.toLowerCase(), eu.has(a))
      return D.QUIRKS;
    let s = t === null ? $t : Xe;
    if (Be(a, s))
      return D.QUIRKS;
    if (s = t === null ? Ve : tu, Be(a, s))
      return D.LIMITED_QUIRKS;
  }
  return D.NO_QUIRKS;
}
const xe = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, su = "definitionurl", ru = "definitionURL", iu = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), nu = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: T.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: T.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: T.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: T.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: T.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: T.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: T.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: T.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: T.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: T.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: T.XMLNS }]
]), cu = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), ou = /* @__PURE__ */ new Set([
  u.B,
  u.BIG,
  u.BLOCKQUOTE,
  u.BODY,
  u.BR,
  u.CENTER,
  u.CODE,
  u.DD,
  u.DIV,
  u.DL,
  u.DT,
  u.EM,
  u.EMBED,
  u.H1,
  u.H2,
  u.H3,
  u.H4,
  u.H5,
  u.H6,
  u.HEAD,
  u.HR,
  u.I,
  u.IMG,
  u.LI,
  u.LISTING,
  u.MENU,
  u.META,
  u.NOBR,
  u.OL,
  u.P,
  u.PRE,
  u.RUBY,
  u.S,
  u.SMALL,
  u.SPAN,
  u.STRONG,
  u.STRIKE,
  u.SUB,
  u.SUP,
  u.TABLE,
  u.TT,
  u.U,
  u.UL,
  u.VAR
]);
function du(e) {
  const t = e.tagID;
  return t === u.FONT && e.attrs.some(({ name: s }) => s === k.COLOR || s === k.SIZE || s === k.FACE) || ou.has(t);
}
function ze(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === su) {
      e.attrs[t].name = ru;
      break;
    }
}
function je(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const a = iu.get(e.attrs[t].name);
    a != null && (e.attrs[t].name = a);
  }
}
function me(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const a = nu.get(e.attrs[t].name);
    a && (e.attrs[t].prefix = a.prefix, e.attrs[t].name = a.name, e.attrs[t].namespace = a.namespace);
  }
}
function Eu(e) {
  const t = cu.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = re(e.tagName));
}
function Tu(e, t) {
  return t === T.MATHML && (e === u.MI || e === u.MO || e === u.MN || e === u.MS || e === u.MTEXT);
}
function hu(e, t, a) {
  if (t === T.MATHML && e === u.ANNOTATION_XML) {
    for (let s = 0; s < a.length; s++)
      if (a[s].name === k.ENCODING) {
        const c = a[s].value.toLowerCase();
        return c === xe.TEXT_HTML || c === xe.APPLICATION_XML;
      }
  }
  return t === T.SVG && (e === u.FOREIGN_OBJECT || e === u.DESC || e === u.TITLE);
}
function lu(e, t, a, s) {
  return (!s || s === T.HTML) && hu(e, t, a) || (!s || s === T.MATHML) && Tu(e, t);
}
const fu = "hidden", _u = 8, mu = 3;
var n;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(n || (n = {}));
const bu = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, Je = /* @__PURE__ */ new Set([u.TABLE, u.TBODY, u.TFOOT, u.THEAD, u.TR]), He = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: B,
  onParseError: null
};
class Ze {
  constructor(t, a, s = null, c = null) {
    this.fragmentContext = s, this.scriptHandler = c, this.currentToken = null, this.stopped = !1, this.insertionMode = n.INITIAL, this.originalInsertionMode = n.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...He,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = a ?? this.treeAdapter.createDocument(), this.tokenizer = new Qt(this.options, this), this.activeFormattingElements = new jt(this.treeAdapter), this.fragmentContextID = s ? re(this.treeAdapter.getTagName(s)) : u.UNKNOWN, this._setContextModes(s ?? this.document, this.fragmentContextID), this.openElements = new zt(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, a) {
    const s = new this(a);
    return s.tokenizer.write(t, !0), s.document;
  }
  static getFragmentParser(t, a) {
    const s = {
      ...He,
      ...a
    };
    t ?? (t = s.treeAdapter.createElement(o.TEMPLATE, T.HTML, []));
    const c = s.treeAdapter.createElement("documentmock", T.HTML, []), d = new this(s, c, t);
    return d.fragmentContextID === u.TEMPLATE && d.tmplInsertionModeStack.unshift(n.IN_TEMPLATE), d._initTokenizerForFragmentParsing(), d._insertFakeRootElement(), d._resetInsertionMode(), d._findFormInFragmentContext(), d;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), a = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, a), a;
  }
  //Errors
  /** @internal */
  _err(t, a, s) {
    var c;
    if (!this.onParseError)
      return;
    const d = (c = t.location) !== null && c !== void 0 ? c : bu, h = {
      code: a,
      startLine: d.startLine,
      startCol: d.startCol,
      startOffset: d.startOffset,
      endLine: s ? d.startLine : d.endLine,
      endCol: s ? d.startCol : d.endCol,
      endOffset: s ? d.startOffset : d.endOffset
    };
    this.onParseError(h);
  }
  //Stack events
  /** @internal */
  onItemPush(t, a, s) {
    var c, d;
    (d = (c = this.treeAdapter).onItemPush) === null || d === void 0 || d.call(c, t), s && this.openElements.stackTop > 0 && this._setContextModes(t, a);
  }
  /** @internal */
  onItemPop(t, a) {
    var s, c;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (c = (s = this.treeAdapter).onItemPop) === null || c === void 0 || c.call(s, t, this.openElements.current), a) {
      let d, h;
      this.openElements.stackTop === 0 && this.fragmentContext ? (d = this.fragmentContext, h = this.fragmentContextID) : { current: d, currentTagId: h } = this.openElements, this._setContextModes(d, h);
    }
  }
  _setContextModes(t, a) {
    const s = t === this.document || t && this.treeAdapter.getNamespaceURI(t) === T.HTML;
    this.currentNotInHTML = !s, this.tokenizer.inForeignNode = !s && t !== void 0 && a !== void 0 && !this._isIntegrationPoint(a, t);
  }
  /** @protected */
  _switchToTextParsing(t, a) {
    this._insertElement(t, T.HTML), this.tokenizer.state = a, this.originalInsertionMode = this.insertionMode, this.insertionMode = n.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = n.TEXT, this.originalInsertionMode = n.IN_BODY, this.tokenizer.state = L.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === o.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== T.HTML))
      switch (this.fragmentContextID) {
        case u.TITLE:
        case u.TEXTAREA: {
          this.tokenizer.state = L.RCDATA;
          break;
        }
        case u.STYLE:
        case u.XMP:
        case u.IFRAME:
        case u.NOEMBED:
        case u.NOFRAMES:
        case u.NOSCRIPT: {
          this.tokenizer.state = L.RAWTEXT;
          break;
        }
        case u.SCRIPT: {
          this.tokenizer.state = L.SCRIPT_DATA;
          break;
        }
        case u.PLAINTEXT: {
          this.tokenizer.state = L.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(t) {
    const a = t.name || "", s = t.publicId || "", c = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, a, s, c), t.location) {
      const h = this.treeAdapter.getChildNodes(this.document).find((f) => this.treeAdapter.isDocumentTypeNode(f));
      h && this.treeAdapter.setNodeSourceCodeLocation(h, t.location);
    }
  }
  /** @protected */
  _attachElementToTree(t, a) {
    if (this.options.sourceCodeLocationInfo) {
      const s = a && {
        ...a,
        startTag: a
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, s);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const s = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(s ?? this.document, t);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(t, a) {
    const s = this.treeAdapter.createElement(t.tagName, a, t.attrs);
    this._attachElementToTree(s, t.location);
  }
  /** @protected */
  _insertElement(t, a) {
    const s = this.treeAdapter.createElement(t.tagName, a, t.attrs);
    this._attachElementToTree(s, t.location), this.openElements.push(s, t.tagID);
  }
  /** @protected */
  _insertFakeElement(t, a) {
    const s = this.treeAdapter.createElement(t, T.HTML, []);
    this._attachElementToTree(s, null), this.openElements.push(s, a);
  }
  /** @protected */
  _insertTemplate(t) {
    const a = this.treeAdapter.createElement(t.tagName, T.HTML, t.attrs), s = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(a, s), this._attachElementToTree(a, t.location), this.openElements.push(a, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(s, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(o.HTML, T.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, u.HTML);
  }
  /** @protected */
  _appendCommentNode(t, a) {
    const s = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(a, s), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(s, t.location);
  }
  /** @protected */
  _insertCharacters(t) {
    let a, s;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: a, beforeElement: s } = this._findFosterParentingLocation(), s ? this.treeAdapter.insertTextBefore(a, t.chars, s) : this.treeAdapter.insertText(a, t.chars)) : (a = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(a, t.chars)), !t.location)
      return;
    const c = this.treeAdapter.getChildNodes(a), d = s ? c.lastIndexOf(s) : c.length, h = c[d - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(h)) {
      const { endLine: _, endCol: A, endOffset: O } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(h, { endLine: _, endCol: A, endOffset: O });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(h, t.location);
  }
  /** @protected */
  _adoptNodes(t, a) {
    for (let s = this.treeAdapter.getFirstChild(t); s; s = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(s), this.treeAdapter.appendChild(a, s);
  }
  /** @protected */
  _setEndLocation(t, a) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && a.location) {
      const s = a.location, c = this.treeAdapter.getTagName(t), d = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        a.type === m.END_TAG && c === a.tagName ? {
          endTag: { ...s },
          endLine: s.endLine,
          endCol: s.endCol,
          endOffset: s.endOffset
        } : {
          endLine: s.startLine,
          endCol: s.startCol,
          endOffset: s.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, d);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let a, s;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (a = this.fragmentContext, s = this.fragmentContextID) : { current: a, currentTagId: s } = this.openElements, t.tagID === u.SVG && this.treeAdapter.getTagName(a) === o.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(a) === T.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === u.MGLYPH || t.tagID === u.MALIGNMARK) && s !== void 0 && !this._isIntegrationPoint(s, a, T.HTML)
    );
  }
  /** @protected */
  _processToken(t) {
    switch (t.type) {
      case m.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case m.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case m.COMMENT: {
        this.onComment(t);
        break;
      }
      case m.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case m.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case m.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case m.EOF: {
        this.onEof(t);
        break;
      }
      case m.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(t, a, s) {
    const c = this.treeAdapter.getNamespaceURI(a), d = this.treeAdapter.getAttrList(a);
    return lu(t, c, d, s);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const a = this.activeFormattingElements.entries.findIndex((c) => c.type === g.Marker || this.openElements.contains(c.element)), s = a === -1 ? t - 1 : a - 1;
      for (let c = s; c >= 0; c--) {
        const d = this.activeFormattingElements.entries[c];
        this._insertElement(d.token, this.treeAdapter.getNamespaceURI(d.element)), d.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = n.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(u.P), this.openElements.popUntilTagNamePopped(u.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case u.TR: {
          this.insertionMode = n.IN_ROW;
          return;
        }
        case u.TBODY:
        case u.THEAD:
        case u.TFOOT: {
          this.insertionMode = n.IN_TABLE_BODY;
          return;
        }
        case u.CAPTION: {
          this.insertionMode = n.IN_CAPTION;
          return;
        }
        case u.COLGROUP: {
          this.insertionMode = n.IN_COLUMN_GROUP;
          return;
        }
        case u.TABLE: {
          this.insertionMode = n.IN_TABLE;
          return;
        }
        case u.BODY: {
          this.insertionMode = n.IN_BODY;
          return;
        }
        case u.FRAMESET: {
          this.insertionMode = n.IN_FRAMESET;
          return;
        }
        case u.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case u.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case u.HTML: {
          this.insertionMode = this.headElement ? n.AFTER_HEAD : n.BEFORE_HEAD;
          return;
        }
        case u.TD:
        case u.TH: {
          if (t > 0) {
            this.insertionMode = n.IN_CELL;
            return;
          }
          break;
        }
        case u.HEAD: {
          if (t > 0) {
            this.insertionMode = n.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = n.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let a = t - 1; a > 0; a--) {
        const s = this.openElements.tagIDs[a];
        if (s === u.TEMPLATE)
          break;
        if (s === u.TABLE) {
          this.insertionMode = n.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = n.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(t) {
    return Je.has(t);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const a = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case u.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(a) === T.HTML)
            return { parent: this.treeAdapter.getTemplateContent(a), beforeElement: null };
          break;
        }
        case u.TABLE: {
          const s = this.treeAdapter.getParentNode(a);
          return s ? { parent: s, beforeElement: a } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(t) {
    const a = this._findFosterParentingLocation();
    a.beforeElement ? this.treeAdapter.insertBefore(a.parent, t, a.beforeElement) : this.treeAdapter.appendChild(a.parent, t);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(t, a) {
    const s = this.treeAdapter.getNamespaceURI(t);
    return yt[s].has(a);
  }
  /** @internal */
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      Va(this, t);
      return;
    }
    switch (this.insertionMode) {
      case n.INITIAL: {
        w(this, t);
        break;
      }
      case n.BEFORE_HTML: {
        Q(this, t);
        break;
      }
      case n.BEFORE_HEAD: {
        W(this, t);
        break;
      }
      case n.IN_HEAD: {
        G(this, t);
        break;
      }
      case n.IN_HEAD_NO_SCRIPT: {
        q(this, t);
        break;
      }
      case n.AFTER_HEAD: {
        K(this, t);
        break;
      }
      case n.IN_BODY:
      case n.IN_CAPTION:
      case n.IN_CELL:
      case n.IN_TEMPLATE: {
        et(this, t);
        break;
      }
      case n.TEXT:
      case n.IN_SELECT:
      case n.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case n.IN_TABLE:
      case n.IN_TABLE_BODY:
      case n.IN_ROW: {
        Ee(this, t);
        break;
      }
      case n.IN_TABLE_TEXT: {
        it(this, t);
        break;
      }
      case n.IN_COLUMN_GROUP: {
        ue(this, t);
        break;
      }
      case n.AFTER_BODY: {
        ae(this, t);
        break;
      }
      case n.AFTER_AFTER_BODY: {
        ee(this, t);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      Xa(this, t);
      return;
    }
    switch (this.insertionMode) {
      case n.INITIAL: {
        w(this, t);
        break;
      }
      case n.BEFORE_HTML: {
        Q(this, t);
        break;
      }
      case n.BEFORE_HEAD: {
        W(this, t);
        break;
      }
      case n.IN_HEAD: {
        G(this, t);
        break;
      }
      case n.IN_HEAD_NO_SCRIPT: {
        q(this, t);
        break;
      }
      case n.AFTER_HEAD: {
        K(this, t);
        break;
      }
      case n.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case n.IN_TABLE:
      case n.IN_TABLE_BODY:
      case n.IN_ROW: {
        Ee(this, t);
        break;
      }
      case n.IN_COLUMN_GROUP: {
        ue(this, t);
        break;
      }
      case n.AFTER_BODY: {
        ae(this, t);
        break;
      }
      case n.AFTER_AFTER_BODY: {
        ee(this, t);
        break;
      }
    }
  }
  /** @internal */
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      le(this, t);
      return;
    }
    switch (this.insertionMode) {
      case n.INITIAL:
      case n.BEFORE_HTML:
      case n.BEFORE_HEAD:
      case n.IN_HEAD:
      case n.IN_HEAD_NO_SCRIPT:
      case n.AFTER_HEAD:
      case n.IN_BODY:
      case n.IN_TABLE:
      case n.IN_CAPTION:
      case n.IN_COLUMN_GROUP:
      case n.IN_TABLE_BODY:
      case n.IN_ROW:
      case n.IN_CELL:
      case n.IN_SELECT:
      case n.IN_SELECT_IN_TABLE:
      case n.IN_TEMPLATE:
      case n.IN_FRAMESET:
      case n.AFTER_FRAMESET: {
        le(this, t);
        break;
      }
      case n.IN_TABLE_TEXT: {
        Y(this, t);
        break;
      }
      case n.AFTER_BODY: {
        Lu(this, t);
        break;
      }
      case n.AFTER_AFTER_BODY:
      case n.AFTER_AFTER_FRAMESET: {
        Ru(this, t);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case n.INITIAL: {
        Du(this, t);
        break;
      }
      case n.BEFORE_HEAD:
      case n.IN_HEAD:
      case n.IN_HEAD_NO_SCRIPT:
      case n.AFTER_HEAD: {
        this._err(t, E.misplacedDoctype);
        break;
      }
      case n.IN_TABLE_TEXT: {
        Y(this, t);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, E.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? za(this, t) : this._startTagOutsideForeignContent(t);
  }
  /** @protected */
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case n.INITIAL: {
        w(this, t);
        break;
      }
      case n.BEFORE_HTML: {
        pu(this, t);
        break;
      }
      case n.BEFORE_HEAD: {
        Pu(this, t);
        break;
      }
      case n.IN_HEAD: {
        p(this, t);
        break;
      }
      case n.IN_HEAD_NO_SCRIPT: {
        xu(this, t);
        break;
      }
      case n.AFTER_HEAD: {
        ku(this, t);
        break;
      }
      case n.IN_BODY: {
        C(this, t);
        break;
      }
      case n.IN_TABLE: {
        y(this, t);
        break;
      }
      case n.IN_TABLE_TEXT: {
        Y(this, t);
        break;
      }
      case n.IN_CAPTION: {
        Ma(this, t);
        break;
      }
      case n.IN_COLUMN_GROUP: {
        Ne(this, t);
        break;
      }
      case n.IN_TABLE_BODY: {
        ce(this, t);
        break;
      }
      case n.IN_ROW: {
        oe(this, t);
        break;
      }
      case n.IN_CELL: {
        Ha(this, t);
        break;
      }
      case n.IN_SELECT: {
        ot(this, t);
        break;
      }
      case n.IN_SELECT_IN_TABLE: {
        Fa(this, t);
        break;
      }
      case n.IN_TEMPLATE: {
        ya(this, t);
        break;
      }
      case n.AFTER_BODY: {
        Ya(this, t);
        break;
      }
      case n.IN_FRAMESET: {
        va(this, t);
        break;
      }
      case n.AFTER_FRAMESET: {
        Wa(this, t);
        break;
      }
      case n.AFTER_AFTER_BODY: {
        qa(this, t);
        break;
      }
      case n.AFTER_AFTER_FRAMESET: {
        Ka(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? ja(this, t) : this._endTagOutsideForeignContent(t);
  }
  /** @protected */
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case n.INITIAL: {
        w(this, t);
        break;
      }
      case n.BEFORE_HTML: {
        gu(this, t);
        break;
      }
      case n.BEFORE_HEAD: {
        Mu(this, t);
        break;
      }
      case n.IN_HEAD: {
        Bu(this, t);
        break;
      }
      case n.IN_HEAD_NO_SCRIPT: {
        Hu(this, t);
        break;
      }
      case n.AFTER_HEAD: {
        Fu(this, t);
        break;
      }
      case n.IN_BODY: {
        ne(this, t);
        break;
      }
      case n.TEXT: {
        Ia(this, t);
        break;
      }
      case n.IN_TABLE: {
        X(this, t);
        break;
      }
      case n.IN_TABLE_TEXT: {
        Y(this, t);
        break;
      }
      case n.IN_CAPTION: {
        Ba(this, t);
        break;
      }
      case n.IN_COLUMN_GROUP: {
        xa(this, t);
        break;
      }
      case n.IN_TABLE_BODY: {
        fe(this, t);
        break;
      }
      case n.IN_ROW: {
        ct(this, t);
        break;
      }
      case n.IN_CELL: {
        ka(this, t);
        break;
      }
      case n.IN_SELECT: {
        dt(this, t);
        break;
      }
      case n.IN_SELECT_IN_TABLE: {
        Ua(this, t);
        break;
      }
      case n.IN_TEMPLATE: {
        wa(this, t);
        break;
      }
      case n.AFTER_BODY: {
        Tt(this, t);
        break;
      }
      case n.IN_FRAMESET: {
        Qa(this, t);
        break;
      }
      case n.AFTER_FRAMESET: {
        Ga(this, t);
        break;
      }
      case n.AFTER_AFTER_BODY: {
        ee(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEof(t) {
    switch (this.insertionMode) {
      case n.INITIAL: {
        w(this, t);
        break;
      }
      case n.BEFORE_HTML: {
        Q(this, t);
        break;
      }
      case n.BEFORE_HEAD: {
        W(this, t);
        break;
      }
      case n.IN_HEAD: {
        G(this, t);
        break;
      }
      case n.IN_HEAD_NO_SCRIPT: {
        q(this, t);
        break;
      }
      case n.AFTER_HEAD: {
        K(this, t);
        break;
      }
      case n.IN_BODY:
      case n.IN_TABLE:
      case n.IN_CAPTION:
      case n.IN_COLUMN_GROUP:
      case n.IN_TABLE_BODY:
      case n.IN_ROW:
      case n.IN_CELL:
      case n.IN_SELECT:
      case n.IN_SELECT_IN_TABLE: {
        st(this, t);
        break;
      }
      case n.TEXT: {
        Ca(this, t);
        break;
      }
      case n.IN_TABLE_TEXT: {
        Y(this, t);
        break;
      }
      case n.IN_TEMPLATE: {
        Et(this, t);
        break;
      }
      case n.AFTER_BODY:
      case n.IN_FRAMESET:
      case n.AFTER_FRAMESET:
      case n.AFTER_AFTER_BODY:
      case n.AFTER_AFTER_FRAMESET: {
        Ae(this, t);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === r.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case n.IN_HEAD:
      case n.IN_HEAD_NO_SCRIPT:
      case n.AFTER_HEAD:
      case n.TEXT:
      case n.IN_COLUMN_GROUP:
      case n.IN_SELECT:
      case n.IN_SELECT_IN_TABLE:
      case n.IN_FRAMESET:
      case n.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case n.IN_BODY:
      case n.IN_CAPTION:
      case n.IN_CELL:
      case n.IN_TEMPLATE:
      case n.AFTER_BODY:
      case n.AFTER_AFTER_BODY:
      case n.AFTER_AFTER_FRAMESET: {
        $e(this, t);
        break;
      }
      case n.IN_TABLE:
      case n.IN_TABLE_BODY:
      case n.IN_ROW: {
        Ee(this, t);
        break;
      }
      case n.IN_TABLE_TEXT: {
        rt(this, t);
        break;
      }
    }
  }
}
function Au(e, t) {
  let a = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return a ? e.openElements.contains(a.element) ? e.openElements.hasInScope(t.tagID) || (a = null) : (e.activeFormattingElements.removeEntry(a), a = null) : at(e, t), a;
}
function Nu(e, t) {
  let a = null, s = e.openElements.stackTop;
  for (; s >= 0; s--) {
    const c = e.openElements.items[s];
    if (c === t.element)
      break;
    e._isSpecialElement(c, e.openElements.tagIDs[s]) && (a = c);
  }
  return a || (e.openElements.shortenToLength(Math.max(s, 0)), e.activeFormattingElements.removeEntry(t)), a;
}
function Iu(e, t, a) {
  let s = t, c = e.openElements.getCommonAncestor(t);
  for (let d = 0, h = c; h !== a; d++, h = c) {
    c = e.openElements.getCommonAncestor(h);
    const f = e.activeFormattingElements.getElementEntry(h), _ = f && d >= mu;
    !f || _ ? (_ && e.activeFormattingElements.removeEntry(f), e.openElements.remove(h)) : (h = Cu(e, f), s === t && (e.activeFormattingElements.bookmark = f), e.treeAdapter.detachNode(s), e.treeAdapter.appendChild(h, s), s = h);
  }
  return s;
}
function Cu(e, t) {
  const a = e.treeAdapter.getNamespaceURI(t.element), s = e.treeAdapter.createElement(t.token.tagName, a, t.token.attrs);
  return e.openElements.replace(t.element, s), t.element = s, s;
}
function Ou(e, t, a) {
  const s = e.treeAdapter.getTagName(t), c = re(s);
  if (e._isElementCausesFosterParenting(c))
    e._fosterParentElement(a);
  else {
    const d = e.treeAdapter.getNamespaceURI(t);
    c === u.TEMPLATE && d === T.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, a);
  }
}
function Su(e, t, a) {
  const s = e.treeAdapter.getNamespaceURI(a.element), { token: c } = a, d = e.treeAdapter.createElement(c.tagName, s, c.attrs);
  e._adoptNodes(t, d), e.treeAdapter.appendChild(t, d), e.activeFormattingElements.insertElementAfterBookmark(d, c), e.activeFormattingElements.removeEntry(a), e.openElements.remove(a.element), e.openElements.insertAfter(t, d, c.tagID);
}
function be(e, t) {
  for (let a = 0; a < _u; a++) {
    const s = Au(e, t);
    if (!s)
      break;
    const c = Nu(e, s);
    if (!c)
      break;
    e.activeFormattingElements.bookmark = s;
    const d = Iu(e, c, s.element), h = e.openElements.getCommonAncestor(s.element);
    e.treeAdapter.detachNode(d), h && Ou(e, h, d), Su(e, c, s);
  }
}
function le(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function Lu(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function Ru(e, t) {
  e._appendCommentNode(t, e.document);
}
function Ae(e, t) {
  if (e.stopped = !0, t.location) {
    const a = e.fragmentContext ? 0 : 2;
    for (let s = e.openElements.stackTop; s >= a; s--)
      e._setEndLocation(e.openElements.items[s], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const s = e.openElements.items[0], c = e.treeAdapter.getNodeSourceCodeLocation(s);
      if (c && !c.endTag && (e._setEndLocation(s, t), e.openElements.stackTop >= 1)) {
        const d = e.openElements.items[1], h = e.treeAdapter.getNodeSourceCodeLocation(d);
        h && !h.endTag && e._setEndLocation(d, t);
      }
    }
  }
}
function Du(e, t) {
  e._setDocumentType(t);
  const a = t.forceQuirks ? D.QUIRKS : au(t);
  uu(t) || e._err(t, E.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, a), e.insertionMode = n.BEFORE_HTML;
}
function w(e, t) {
  e._err(t, E.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, D.QUIRKS), e.insertionMode = n.BEFORE_HTML, e._processToken(t);
}
function pu(e, t) {
  t.tagID === u.HTML ? (e._insertElement(t, T.HTML), e.insertionMode = n.BEFORE_HEAD) : Q(e, t);
}
function gu(e, t) {
  const a = t.tagID;
  (a === u.HTML || a === u.HEAD || a === u.BODY || a === u.BR) && Q(e, t);
}
function Q(e, t) {
  e._insertFakeRootElement(), e.insertionMode = n.BEFORE_HEAD, e._processToken(t);
}
function Pu(e, t) {
  switch (t.tagID) {
    case u.HTML: {
      C(e, t);
      break;
    }
    case u.HEAD: {
      e._insertElement(t, T.HTML), e.headElement = e.openElements.current, e.insertionMode = n.IN_HEAD;
      break;
    }
    default:
      W(e, t);
  }
}
function Mu(e, t) {
  const a = t.tagID;
  a === u.HEAD || a === u.BODY || a === u.HTML || a === u.BR ? W(e, t) : e._err(t, E.endTagWithoutMatchingOpenElement);
}
function W(e, t) {
  e._insertFakeElement(o.HEAD, u.HEAD), e.headElement = e.openElements.current, e.insertionMode = n.IN_HEAD, e._processToken(t);
}
function p(e, t) {
  switch (t.tagID) {
    case u.HTML: {
      C(e, t);
      break;
    }
    case u.BASE:
    case u.BASEFONT:
    case u.BGSOUND:
    case u.LINK:
    case u.META: {
      e._appendElement(t, T.HTML), t.ackSelfClosing = !0;
      break;
    }
    case u.TITLE: {
      e._switchToTextParsing(t, L.RCDATA);
      break;
    }
    case u.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, L.RAWTEXT) : (e._insertElement(t, T.HTML), e.insertionMode = n.IN_HEAD_NO_SCRIPT);
      break;
    }
    case u.NOFRAMES:
    case u.STYLE: {
      e._switchToTextParsing(t, L.RAWTEXT);
      break;
    }
    case u.SCRIPT: {
      e._switchToTextParsing(t, L.SCRIPT_DATA);
      break;
    }
    case u.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = n.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(n.IN_TEMPLATE);
      break;
    }
    case u.HEAD: {
      e._err(t, E.misplacedStartTagForHeadElement);
      break;
    }
    default:
      G(e, t);
  }
}
function Bu(e, t) {
  switch (t.tagID) {
    case u.HEAD: {
      e.openElements.pop(), e.insertionMode = n.AFTER_HEAD;
      break;
    }
    case u.BODY:
    case u.BR:
    case u.HTML: {
      G(e, t);
      break;
    }
    case u.TEMPLATE: {
      F(e, t);
      break;
    }
    default:
      e._err(t, E.endTagWithoutMatchingOpenElement);
  }
}
function F(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== u.TEMPLATE && e._err(t, E.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(u.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, E.endTagWithoutMatchingOpenElement);
}
function G(e, t) {
  e.openElements.pop(), e.insertionMode = n.AFTER_HEAD, e._processToken(t);
}
function xu(e, t) {
  switch (t.tagID) {
    case u.HTML: {
      C(e, t);
      break;
    }
    case u.BASEFONT:
    case u.BGSOUND:
    case u.HEAD:
    case u.LINK:
    case u.META:
    case u.NOFRAMES:
    case u.STYLE: {
      p(e, t);
      break;
    }
    case u.NOSCRIPT: {
      e._err(t, E.nestedNoscriptInHead);
      break;
    }
    default:
      q(e, t);
  }
}
function Hu(e, t) {
  switch (t.tagID) {
    case u.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = n.IN_HEAD;
      break;
    }
    case u.BR: {
      q(e, t);
      break;
    }
    default:
      e._err(t, E.endTagWithoutMatchingOpenElement);
  }
}
function q(e, t) {
  const a = t.type === m.EOF ? E.openElementsLeftAfterEof : E.disallowedContentInNoscriptInHead;
  e._err(t, a), e.openElements.pop(), e.insertionMode = n.IN_HEAD, e._processToken(t);
}
function ku(e, t) {
  switch (t.tagID) {
    case u.HTML: {
      C(e, t);
      break;
    }
    case u.BODY: {
      e._insertElement(t, T.HTML), e.framesetOk = !1, e.insertionMode = n.IN_BODY;
      break;
    }
    case u.FRAMESET: {
      e._insertElement(t, T.HTML), e.insertionMode = n.IN_FRAMESET;
      break;
    }
    case u.BASE:
    case u.BASEFONT:
    case u.BGSOUND:
    case u.LINK:
    case u.META:
    case u.NOFRAMES:
    case u.SCRIPT:
    case u.STYLE:
    case u.TEMPLATE:
    case u.TITLE: {
      e._err(t, E.abandonedHeadElementChild), e.openElements.push(e.headElement, u.HEAD), p(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case u.HEAD: {
      e._err(t, E.misplacedStartTagForHeadElement);
      break;
    }
    default:
      K(e, t);
  }
}
function Fu(e, t) {
  switch (t.tagID) {
    case u.BODY:
    case u.HTML:
    case u.BR: {
      K(e, t);
      break;
    }
    case u.TEMPLATE: {
      F(e, t);
      break;
    }
    default:
      e._err(t, E.endTagWithoutMatchingOpenElement);
  }
}
function K(e, t) {
  e._insertFakeElement(o.BODY, u.BODY), e.insertionMode = n.IN_BODY, ie(e, t);
}
function ie(e, t) {
  switch (t.type) {
    case m.CHARACTER: {
      et(e, t);
      break;
    }
    case m.WHITESPACE_CHARACTER: {
      $e(e, t);
      break;
    }
    case m.COMMENT: {
      le(e, t);
      break;
    }
    case m.START_TAG: {
      C(e, t);
      break;
    }
    case m.END_TAG: {
      ne(e, t);
      break;
    }
    case m.EOF: {
      st(e, t);
      break;
    }
  }
}
function $e(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function et(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function Uu(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function yu(e, t) {
  const a = e.openElements.tryPeekProperlyNestedBodyElement();
  a && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(a, t.attrs));
}
function wu(e, t) {
  const a = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && a && (e.treeAdapter.detachNode(a), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, T.HTML), e.insertionMode = n.IN_FRAMESET);
}
function Yu(e, t) {
  e.openElements.hasInButtonScope(u.P) && e._closePElement(), e._insertElement(t, T.HTML);
}
function vu(e, t) {
  e.openElements.hasInButtonScope(u.P) && e._closePElement(), e.openElements.currentTagId !== void 0 && he.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, T.HTML);
}
function Qu(e, t) {
  e.openElements.hasInButtonScope(u.P) && e._closePElement(), e._insertElement(t, T.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function Wu(e, t) {
  const a = e.openElements.tmplCount > 0;
  (!e.formElement || a) && (e.openElements.hasInButtonScope(u.P) && e._closePElement(), e._insertElement(t, T.HTML), a || (e.formElement = e.openElements.current));
}
function Gu(e, t) {
  e.framesetOk = !1;
  const a = t.tagID;
  for (let s = e.openElements.stackTop; s >= 0; s--) {
    const c = e.openElements.tagIDs[s];
    if (a === u.LI && c === u.LI || (a === u.DD || a === u.DT) && (c === u.DD || c === u.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(c), e.openElements.popUntilTagNamePopped(c);
      break;
    }
    if (c !== u.ADDRESS && c !== u.DIV && c !== u.P && e._isSpecialElement(e.openElements.items[s], c))
      break;
  }
  e.openElements.hasInButtonScope(u.P) && e._closePElement(), e._insertElement(t, T.HTML);
}
function qu(e, t) {
  e.openElements.hasInButtonScope(u.P) && e._closePElement(), e._insertElement(t, T.HTML), e.tokenizer.state = L.PLAINTEXT;
}
function Ku(e, t) {
  e.openElements.hasInScope(u.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(u.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, T.HTML), e.framesetOk = !1;
}
function Xu(e, t) {
  const a = e.activeFormattingElements.getElementEntryInScopeWithTagName(o.A);
  a && (be(e, t), e.openElements.remove(a.element), e.activeFormattingElements.removeEntry(a)), e._reconstructActiveFormattingElements(), e._insertElement(t, T.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function Vu(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, T.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function zu(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(u.NOBR) && (be(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, T.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function ju(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, T.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function Ju(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== D.QUIRKS && e.openElements.hasInButtonScope(u.P) && e._closePElement(), e._insertElement(t, T.HTML), e.framesetOk = !1, e.insertionMode = n.IN_TABLE;
}
function tt(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, T.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function ut(e) {
  const t = We(e, k.TYPE);
  return t != null && t.toLowerCase() === fu;
}
function Zu(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, T.HTML), ut(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function $u(e, t) {
  e._appendElement(t, T.HTML), t.ackSelfClosing = !0;
}
function ea(e, t) {
  e.openElements.hasInButtonScope(u.P) && e._closePElement(), e._appendElement(t, T.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function ta(e, t) {
  t.tagName = o.IMG, t.tagID = u.IMG, tt(e, t);
}
function ua(e, t) {
  e._insertElement(t, T.HTML), e.skipNextNewLine = !0, e.tokenizer.state = L.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = n.TEXT;
}
function aa(e, t) {
  e.openElements.hasInButtonScope(u.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, L.RAWTEXT);
}
function sa(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, L.RAWTEXT);
}
function ke(e, t) {
  e._switchToTextParsing(t, L.RAWTEXT);
}
function ra(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, T.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === n.IN_TABLE || e.insertionMode === n.IN_CAPTION || e.insertionMode === n.IN_TABLE_BODY || e.insertionMode === n.IN_ROW || e.insertionMode === n.IN_CELL ? n.IN_SELECT_IN_TABLE : n.IN_SELECT;
}
function ia(e, t) {
  e.openElements.currentTagId === u.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, T.HTML);
}
function na(e, t) {
  e.openElements.hasInScope(u.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, T.HTML);
}
function ca(e, t) {
  e.openElements.hasInScope(u.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(u.RTC), e._insertElement(t, T.HTML);
}
function oa(e, t) {
  e._reconstructActiveFormattingElements(), ze(t), me(t), t.selfClosing ? e._appendElement(t, T.MATHML) : e._insertElement(t, T.MATHML), t.ackSelfClosing = !0;
}
function da(e, t) {
  e._reconstructActiveFormattingElements(), je(t), me(t), t.selfClosing ? e._appendElement(t, T.SVG) : e._insertElement(t, T.SVG), t.ackSelfClosing = !0;
}
function Fe(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, T.HTML);
}
function C(e, t) {
  switch (t.tagID) {
    case u.I:
    case u.S:
    case u.B:
    case u.U:
    case u.EM:
    case u.TT:
    case u.BIG:
    case u.CODE:
    case u.FONT:
    case u.SMALL:
    case u.STRIKE:
    case u.STRONG: {
      Vu(e, t);
      break;
    }
    case u.A: {
      Xu(e, t);
      break;
    }
    case u.H1:
    case u.H2:
    case u.H3:
    case u.H4:
    case u.H5:
    case u.H6: {
      vu(e, t);
      break;
    }
    case u.P:
    case u.DL:
    case u.OL:
    case u.UL:
    case u.DIV:
    case u.DIR:
    case u.NAV:
    case u.MAIN:
    case u.MENU:
    case u.ASIDE:
    case u.CENTER:
    case u.FIGURE:
    case u.FOOTER:
    case u.HEADER:
    case u.HGROUP:
    case u.DIALOG:
    case u.DETAILS:
    case u.ADDRESS:
    case u.ARTICLE:
    case u.SEARCH:
    case u.SECTION:
    case u.SUMMARY:
    case u.FIELDSET:
    case u.BLOCKQUOTE:
    case u.FIGCAPTION: {
      Yu(e, t);
      break;
    }
    case u.LI:
    case u.DD:
    case u.DT: {
      Gu(e, t);
      break;
    }
    case u.BR:
    case u.IMG:
    case u.WBR:
    case u.AREA:
    case u.EMBED:
    case u.KEYGEN: {
      tt(e, t);
      break;
    }
    case u.HR: {
      ea(e, t);
      break;
    }
    case u.RB:
    case u.RTC: {
      na(e, t);
      break;
    }
    case u.RT:
    case u.RP: {
      ca(e, t);
      break;
    }
    case u.PRE:
    case u.LISTING: {
      Qu(e, t);
      break;
    }
    case u.XMP: {
      aa(e, t);
      break;
    }
    case u.SVG: {
      da(e, t);
      break;
    }
    case u.HTML: {
      Uu(e, t);
      break;
    }
    case u.BASE:
    case u.LINK:
    case u.META:
    case u.STYLE:
    case u.TITLE:
    case u.SCRIPT:
    case u.BGSOUND:
    case u.BASEFONT:
    case u.TEMPLATE: {
      p(e, t);
      break;
    }
    case u.BODY: {
      yu(e, t);
      break;
    }
    case u.FORM: {
      Wu(e, t);
      break;
    }
    case u.NOBR: {
      zu(e, t);
      break;
    }
    case u.MATH: {
      oa(e, t);
      break;
    }
    case u.TABLE: {
      Ju(e, t);
      break;
    }
    case u.INPUT: {
      Zu(e, t);
      break;
    }
    case u.PARAM:
    case u.TRACK:
    case u.SOURCE: {
      $u(e, t);
      break;
    }
    case u.IMAGE: {
      ta(e, t);
      break;
    }
    case u.BUTTON: {
      Ku(e, t);
      break;
    }
    case u.APPLET:
    case u.OBJECT:
    case u.MARQUEE: {
      ju(e, t);
      break;
    }
    case u.IFRAME: {
      sa(e, t);
      break;
    }
    case u.SELECT: {
      ra(e, t);
      break;
    }
    case u.OPTION:
    case u.OPTGROUP: {
      ia(e, t);
      break;
    }
    case u.NOEMBED:
    case u.NOFRAMES: {
      ke(e, t);
      break;
    }
    case u.FRAMESET: {
      wu(e, t);
      break;
    }
    case u.TEXTAREA: {
      ua(e, t);
      break;
    }
    case u.NOSCRIPT: {
      e.options.scriptingEnabled ? ke(e, t) : Fe(e, t);
      break;
    }
    case u.PLAINTEXT: {
      qu(e, t);
      break;
    }
    case u.COL:
    case u.TH:
    case u.TD:
    case u.TR:
    case u.HEAD:
    case u.FRAME:
    case u.TBODY:
    case u.TFOOT:
    case u.THEAD:
    case u.CAPTION:
    case u.COLGROUP:
      break;
    default:
      Fe(e, t);
  }
}
function Ea(e, t) {
  if (e.openElements.hasInScope(u.BODY) && (e.insertionMode = n.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const a = e.openElements.tryPeekProperlyNestedBodyElement();
    a && e._setEndLocation(a, t);
  }
}
function Ta(e, t) {
  e.openElements.hasInScope(u.BODY) && (e.insertionMode = n.AFTER_BODY, Tt(e, t));
}
function ha(e, t) {
  const a = t.tagID;
  e.openElements.hasInScope(a) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(a));
}
function la(e) {
  const t = e.openElements.tmplCount > 0, { formElement: a } = e;
  t || (e.formElement = null), (a || t) && e.openElements.hasInScope(u.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(u.FORM) : a && e.openElements.remove(a));
}
function fa(e) {
  e.openElements.hasInButtonScope(u.P) || e._insertFakeElement(o.P, u.P), e._closePElement();
}
function _a(e) {
  e.openElements.hasInListItemScope(u.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(u.LI), e.openElements.popUntilTagNamePopped(u.LI));
}
function ma(e, t) {
  const a = t.tagID;
  e.openElements.hasInScope(a) && (e.openElements.generateImpliedEndTagsWithExclusion(a), e.openElements.popUntilTagNamePopped(a));
}
function ba(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function Aa(e, t) {
  const a = t.tagID;
  e.openElements.hasInScope(a) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(a), e.activeFormattingElements.clearToLastMarker());
}
function Na(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(o.BR, u.BR), e.openElements.pop(), e.framesetOk = !1;
}
function at(e, t) {
  const a = t.tagName, s = t.tagID;
  for (let c = e.openElements.stackTop; c > 0; c--) {
    const d = e.openElements.items[c], h = e.openElements.tagIDs[c];
    if (s === h && (s !== u.UNKNOWN || e.treeAdapter.getTagName(d) === a)) {
      e.openElements.generateImpliedEndTagsWithExclusion(s), e.openElements.stackTop >= c && e.openElements.shortenToLength(c);
      break;
    }
    if (e._isSpecialElement(d, h))
      break;
  }
}
function ne(e, t) {
  switch (t.tagID) {
    case u.A:
    case u.B:
    case u.I:
    case u.S:
    case u.U:
    case u.EM:
    case u.TT:
    case u.BIG:
    case u.CODE:
    case u.FONT:
    case u.NOBR:
    case u.SMALL:
    case u.STRIKE:
    case u.STRONG: {
      be(e, t);
      break;
    }
    case u.P: {
      fa(e);
      break;
    }
    case u.DL:
    case u.UL:
    case u.OL:
    case u.DIR:
    case u.DIV:
    case u.NAV:
    case u.PRE:
    case u.MAIN:
    case u.MENU:
    case u.ASIDE:
    case u.BUTTON:
    case u.CENTER:
    case u.FIGURE:
    case u.FOOTER:
    case u.HEADER:
    case u.HGROUP:
    case u.DIALOG:
    case u.ADDRESS:
    case u.ARTICLE:
    case u.DETAILS:
    case u.SEARCH:
    case u.SECTION:
    case u.SUMMARY:
    case u.LISTING:
    case u.FIELDSET:
    case u.BLOCKQUOTE:
    case u.FIGCAPTION: {
      ha(e, t);
      break;
    }
    case u.LI: {
      _a(e);
      break;
    }
    case u.DD:
    case u.DT: {
      ma(e, t);
      break;
    }
    case u.H1:
    case u.H2:
    case u.H3:
    case u.H4:
    case u.H5:
    case u.H6: {
      ba(e);
      break;
    }
    case u.BR: {
      Na(e);
      break;
    }
    case u.BODY: {
      Ea(e, t);
      break;
    }
    case u.HTML: {
      Ta(e, t);
      break;
    }
    case u.FORM: {
      la(e);
      break;
    }
    case u.APPLET:
    case u.OBJECT:
    case u.MARQUEE: {
      Aa(e, t);
      break;
    }
    case u.TEMPLATE: {
      F(e, t);
      break;
    }
    default:
      at(e, t);
  }
}
function st(e, t) {
  e.tmplInsertionModeStack.length > 0 ? Et(e, t) : Ae(e, t);
}
function Ia(e, t) {
  var a;
  t.tagID === u.SCRIPT && ((a = e.scriptHandler) === null || a === void 0 || a.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function Ca(e, t) {
  e._err(t, E.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function Ee(e, t) {
  if (e.openElements.currentTagId !== void 0 && Je.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = n.IN_TABLE_TEXT, t.type) {
      case m.CHARACTER: {
        it(e, t);
        break;
      }
      case m.WHITESPACE_CHARACTER: {
        rt(e, t);
        break;
      }
    }
  else
    z(e, t);
}
function Oa(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, T.HTML), e.insertionMode = n.IN_CAPTION;
}
function Sa(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, T.HTML), e.insertionMode = n.IN_COLUMN_GROUP;
}
function La(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(o.COLGROUP, u.COLGROUP), e.insertionMode = n.IN_COLUMN_GROUP, Ne(e, t);
}
function Ra(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, T.HTML), e.insertionMode = n.IN_TABLE_BODY;
}
function Da(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(o.TBODY, u.TBODY), e.insertionMode = n.IN_TABLE_BODY, ce(e, t);
}
function pa(e, t) {
  e.openElements.hasInTableScope(u.TABLE) && (e.openElements.popUntilTagNamePopped(u.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function ga(e, t) {
  ut(t) ? e._appendElement(t, T.HTML) : z(e, t), t.ackSelfClosing = !0;
}
function Pa(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, T.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function y(e, t) {
  switch (t.tagID) {
    case u.TD:
    case u.TH:
    case u.TR: {
      Da(e, t);
      break;
    }
    case u.STYLE:
    case u.SCRIPT:
    case u.TEMPLATE: {
      p(e, t);
      break;
    }
    case u.COL: {
      La(e, t);
      break;
    }
    case u.FORM: {
      Pa(e, t);
      break;
    }
    case u.TABLE: {
      pa(e, t);
      break;
    }
    case u.TBODY:
    case u.TFOOT:
    case u.THEAD: {
      Ra(e, t);
      break;
    }
    case u.INPUT: {
      ga(e, t);
      break;
    }
    case u.CAPTION: {
      Oa(e, t);
      break;
    }
    case u.COLGROUP: {
      Sa(e, t);
      break;
    }
    default:
      z(e, t);
  }
}
function X(e, t) {
  switch (t.tagID) {
    case u.TABLE: {
      e.openElements.hasInTableScope(u.TABLE) && (e.openElements.popUntilTagNamePopped(u.TABLE), e._resetInsertionMode());
      break;
    }
    case u.TEMPLATE: {
      F(e, t);
      break;
    }
    case u.BODY:
    case u.CAPTION:
    case u.COL:
    case u.COLGROUP:
    case u.HTML:
    case u.TBODY:
    case u.TD:
    case u.TFOOT:
    case u.TH:
    case u.THEAD:
    case u.TR:
      break;
    default:
      z(e, t);
  }
}
function z(e, t) {
  const a = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, ie(e, t), e.fosterParentingEnabled = a;
}
function rt(e, t) {
  e.pendingCharacterTokens.push(t);
}
function it(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function Y(e, t) {
  let a = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; a < e.pendingCharacterTokens.length; a++)
      z(e, e.pendingCharacterTokens[a]);
  else
    for (; a < e.pendingCharacterTokens.length; a++)
      e._insertCharacters(e.pendingCharacterTokens[a]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const nt = /* @__PURE__ */ new Set([u.CAPTION, u.COL, u.COLGROUP, u.TBODY, u.TD, u.TFOOT, u.TH, u.THEAD, u.TR]);
function Ma(e, t) {
  const a = t.tagID;
  nt.has(a) ? e.openElements.hasInTableScope(u.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(u.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = n.IN_TABLE, y(e, t)) : C(e, t);
}
function Ba(e, t) {
  const a = t.tagID;
  switch (a) {
    case u.CAPTION:
    case u.TABLE: {
      e.openElements.hasInTableScope(u.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(u.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = n.IN_TABLE, a === u.TABLE && X(e, t));
      break;
    }
    case u.BODY:
    case u.COL:
    case u.COLGROUP:
    case u.HTML:
    case u.TBODY:
    case u.TD:
    case u.TFOOT:
    case u.TH:
    case u.THEAD:
    case u.TR:
      break;
    default:
      ne(e, t);
  }
}
function Ne(e, t) {
  switch (t.tagID) {
    case u.HTML: {
      C(e, t);
      break;
    }
    case u.COL: {
      e._appendElement(t, T.HTML), t.ackSelfClosing = !0;
      break;
    }
    case u.TEMPLATE: {
      p(e, t);
      break;
    }
    default:
      ue(e, t);
  }
}
function xa(e, t) {
  switch (t.tagID) {
    case u.COLGROUP: {
      e.openElements.currentTagId === u.COLGROUP && (e.openElements.pop(), e.insertionMode = n.IN_TABLE);
      break;
    }
    case u.TEMPLATE: {
      F(e, t);
      break;
    }
    case u.COL:
      break;
    default:
      ue(e, t);
  }
}
function ue(e, t) {
  e.openElements.currentTagId === u.COLGROUP && (e.openElements.pop(), e.insertionMode = n.IN_TABLE, e._processToken(t));
}
function ce(e, t) {
  switch (t.tagID) {
    case u.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, T.HTML), e.insertionMode = n.IN_ROW;
      break;
    }
    case u.TH:
    case u.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(o.TR, u.TR), e.insertionMode = n.IN_ROW, oe(e, t);
      break;
    }
    case u.CAPTION:
    case u.COL:
    case u.COLGROUP:
    case u.TBODY:
    case u.TFOOT:
    case u.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = n.IN_TABLE, y(e, t));
      break;
    }
    default:
      y(e, t);
  }
}
function fe(e, t) {
  const a = t.tagID;
  switch (t.tagID) {
    case u.TBODY:
    case u.TFOOT:
    case u.THEAD: {
      e.openElements.hasInTableScope(a) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = n.IN_TABLE);
      break;
    }
    case u.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = n.IN_TABLE, X(e, t));
      break;
    }
    case u.BODY:
    case u.CAPTION:
    case u.COL:
    case u.COLGROUP:
    case u.HTML:
    case u.TD:
    case u.TH:
    case u.TR:
      break;
    default:
      X(e, t);
  }
}
function oe(e, t) {
  switch (t.tagID) {
    case u.TH:
    case u.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, T.HTML), e.insertionMode = n.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case u.CAPTION:
    case u.COL:
    case u.COLGROUP:
    case u.TBODY:
    case u.TFOOT:
    case u.THEAD:
    case u.TR: {
      e.openElements.hasInTableScope(u.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = n.IN_TABLE_BODY, ce(e, t));
      break;
    }
    default:
      y(e, t);
  }
}
function ct(e, t) {
  switch (t.tagID) {
    case u.TR: {
      e.openElements.hasInTableScope(u.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = n.IN_TABLE_BODY);
      break;
    }
    case u.TABLE: {
      e.openElements.hasInTableScope(u.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = n.IN_TABLE_BODY, fe(e, t));
      break;
    }
    case u.TBODY:
    case u.TFOOT:
    case u.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(u.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = n.IN_TABLE_BODY, fe(e, t));
      break;
    }
    case u.BODY:
    case u.CAPTION:
    case u.COL:
    case u.COLGROUP:
    case u.HTML:
    case u.TD:
    case u.TH:
      break;
    default:
      X(e, t);
  }
}
function Ha(e, t) {
  const a = t.tagID;
  nt.has(a) ? (e.openElements.hasInTableScope(u.TD) || e.openElements.hasInTableScope(u.TH)) && (e._closeTableCell(), oe(e, t)) : C(e, t);
}
function ka(e, t) {
  const a = t.tagID;
  switch (a) {
    case u.TD:
    case u.TH: {
      e.openElements.hasInTableScope(a) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(a), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = n.IN_ROW);
      break;
    }
    case u.TABLE:
    case u.TBODY:
    case u.TFOOT:
    case u.THEAD:
    case u.TR: {
      e.openElements.hasInTableScope(a) && (e._closeTableCell(), ct(e, t));
      break;
    }
    case u.BODY:
    case u.CAPTION:
    case u.COL:
    case u.COLGROUP:
    case u.HTML:
      break;
    default:
      ne(e, t);
  }
}
function ot(e, t) {
  switch (t.tagID) {
    case u.HTML: {
      C(e, t);
      break;
    }
    case u.OPTION: {
      e.openElements.currentTagId === u.OPTION && e.openElements.pop(), e._insertElement(t, T.HTML);
      break;
    }
    case u.OPTGROUP: {
      e.openElements.currentTagId === u.OPTION && e.openElements.pop(), e.openElements.currentTagId === u.OPTGROUP && e.openElements.pop(), e._insertElement(t, T.HTML);
      break;
    }
    case u.HR: {
      e.openElements.currentTagId === u.OPTION && e.openElements.pop(), e.openElements.currentTagId === u.OPTGROUP && e.openElements.pop(), e._appendElement(t, T.HTML), t.ackSelfClosing = !0;
      break;
    }
    case u.INPUT:
    case u.KEYGEN:
    case u.TEXTAREA:
    case u.SELECT: {
      e.openElements.hasInSelectScope(u.SELECT) && (e.openElements.popUntilTagNamePopped(u.SELECT), e._resetInsertionMode(), t.tagID !== u.SELECT && e._processStartTag(t));
      break;
    }
    case u.SCRIPT:
    case u.TEMPLATE: {
      p(e, t);
      break;
    }
  }
}
function dt(e, t) {
  switch (t.tagID) {
    case u.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === u.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === u.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === u.OPTGROUP && e.openElements.pop();
      break;
    }
    case u.OPTION: {
      e.openElements.currentTagId === u.OPTION && e.openElements.pop();
      break;
    }
    case u.SELECT: {
      e.openElements.hasInSelectScope(u.SELECT) && (e.openElements.popUntilTagNamePopped(u.SELECT), e._resetInsertionMode());
      break;
    }
    case u.TEMPLATE: {
      F(e, t);
      break;
    }
  }
}
function Fa(e, t) {
  const a = t.tagID;
  a === u.CAPTION || a === u.TABLE || a === u.TBODY || a === u.TFOOT || a === u.THEAD || a === u.TR || a === u.TD || a === u.TH ? (e.openElements.popUntilTagNamePopped(u.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : ot(e, t);
}
function Ua(e, t) {
  const a = t.tagID;
  a === u.CAPTION || a === u.TABLE || a === u.TBODY || a === u.TFOOT || a === u.THEAD || a === u.TR || a === u.TD || a === u.TH ? e.openElements.hasInTableScope(a) && (e.openElements.popUntilTagNamePopped(u.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : dt(e, t);
}
function ya(e, t) {
  switch (t.tagID) {
    // First, handle tags that can start without a mode change
    case u.BASE:
    case u.BASEFONT:
    case u.BGSOUND:
    case u.LINK:
    case u.META:
    case u.NOFRAMES:
    case u.SCRIPT:
    case u.STYLE:
    case u.TEMPLATE:
    case u.TITLE: {
      p(e, t);
      break;
    }
    // Re-process the token in the appropriate mode
    case u.CAPTION:
    case u.COLGROUP:
    case u.TBODY:
    case u.TFOOT:
    case u.THEAD: {
      e.tmplInsertionModeStack[0] = n.IN_TABLE, e.insertionMode = n.IN_TABLE, y(e, t);
      break;
    }
    case u.COL: {
      e.tmplInsertionModeStack[0] = n.IN_COLUMN_GROUP, e.insertionMode = n.IN_COLUMN_GROUP, Ne(e, t);
      break;
    }
    case u.TR: {
      e.tmplInsertionModeStack[0] = n.IN_TABLE_BODY, e.insertionMode = n.IN_TABLE_BODY, ce(e, t);
      break;
    }
    case u.TD:
    case u.TH: {
      e.tmplInsertionModeStack[0] = n.IN_ROW, e.insertionMode = n.IN_ROW, oe(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = n.IN_BODY, e.insertionMode = n.IN_BODY, C(e, t);
  }
}
function wa(e, t) {
  t.tagID === u.TEMPLATE && F(e, t);
}
function Et(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(u.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : Ae(e, t);
}
function Ya(e, t) {
  t.tagID === u.HTML ? C(e, t) : ae(e, t);
}
function Tt(e, t) {
  var a;
  if (t.tagID === u.HTML) {
    if (e.fragmentContext || (e.insertionMode = n.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === u.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const s = e.openElements.items[1];
      s && !(!((a = e.treeAdapter.getNodeSourceCodeLocation(s)) === null || a === void 0) && a.endTag) && e._setEndLocation(s, t);
    }
  } else
    ae(e, t);
}
function ae(e, t) {
  e.insertionMode = n.IN_BODY, ie(e, t);
}
function va(e, t) {
  switch (t.tagID) {
    case u.HTML: {
      C(e, t);
      break;
    }
    case u.FRAMESET: {
      e._insertElement(t, T.HTML);
      break;
    }
    case u.FRAME: {
      e._appendElement(t, T.HTML), t.ackSelfClosing = !0;
      break;
    }
    case u.NOFRAMES: {
      p(e, t);
      break;
    }
  }
}
function Qa(e, t) {
  t.tagID === u.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== u.FRAMESET && (e.insertionMode = n.AFTER_FRAMESET));
}
function Wa(e, t) {
  switch (t.tagID) {
    case u.HTML: {
      C(e, t);
      break;
    }
    case u.NOFRAMES: {
      p(e, t);
      break;
    }
  }
}
function Ga(e, t) {
  t.tagID === u.HTML && (e.insertionMode = n.AFTER_AFTER_FRAMESET);
}
function qa(e, t) {
  t.tagID === u.HTML ? C(e, t) : ee(e, t);
}
function ee(e, t) {
  e.insertionMode = n.IN_BODY, ie(e, t);
}
function Ka(e, t) {
  switch (t.tagID) {
    case u.HTML: {
      C(e, t);
      break;
    }
    case u.NOFRAMES: {
      p(e, t);
      break;
    }
  }
}
function Xa(e, t) {
  t.chars = b, e._insertCharacters(t);
}
function Va(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function ht(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== T.HTML && e.openElements.currentTagId !== void 0 && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function za(e, t) {
  if (du(t))
    ht(e), e._startTagOutsideForeignContent(t);
  else {
    const a = e._getAdjustedCurrentElement(), s = e.treeAdapter.getNamespaceURI(a);
    s === T.MATHML ? ze(t) : s === T.SVG && (Eu(t), je(t)), me(t), t.selfClosing ? e._appendElement(t, s) : e._insertElement(t, s), t.ackSelfClosing = !0;
  }
}
function ja(e, t) {
  if (t.tagID === u.P || t.tagID === u.BR) {
    ht(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let a = e.openElements.stackTop; a > 0; a--) {
    const s = e.openElements.items[a];
    if (e.treeAdapter.getNamespaceURI(s) === T.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const c = e.treeAdapter.getTagName(s);
    if (c.toLowerCase() === t.tagName) {
      t.tagName = c, e.openElements.shortenToLength(a);
      break;
    }
  }
}
o.AREA, o.BASE, o.BASEFONT, o.BGSOUND, o.BR, o.COL, o.EMBED, o.FRAME, o.HR, o.IMG, o.INPUT, o.KEYGEN, o.LINK, o.META, o.PARAM, o.SOURCE, o.TRACK, o.WBR;
function Ja(e, t) {
  return Ze.parse(e, t);
}
function Za(e, t, a) {
  typeof e == "string" && (a = t, t = e, e = null);
  const s = Ze.getFragmentParser(e, a);
  return s.tokenizer.write(t, !0), s.getFragment();
}
var lt, _e, ft, $a = [];
function V(e, t, a) {
  var s, c, d, h = {};
  for (d in t) d == "key" ? s = t[d] : d == "ref" ? c = t[d] : h[d] = t[d];
  if (arguments.length > 2 && (h.children = arguments.length > 3 ? lt.call(arguments, 2) : a), typeof e == "function" && e.defaultProps != null) for (d in e.defaultProps) h[d] === void 0 && (h[d] = e.defaultProps[d]);
  return es(e, h, s, c, null);
}
function es(e, t, a, s, c) {
  var d = { type: e, props: t, key: a, ref: s, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: c ?? ++ft, __i: -1, __u: 0 };
  return _e.vnode != null && _e.vnode(d), d;
}
lt = $a.slice, _e = { __e: function(e, t, a, s) {
  for (var c, d, h; t = t.__; ) if ((c = t.__c) && !c.__) try {
    if ((d = c.constructor) && d.getDerivedStateFromError != null && (c.setState(d.getDerivedStateFromError(e)), h = c.__d), c.componentDidCatch != null && (c.componentDidCatch(e, s || {}), h = c.__d), h) return c.__E = c;
  } catch (f) {
    e = f;
  }
  throw e;
} }, ft = 0, typeof Promise == "function" && Promise.prototype.then.bind(Promise.resolve());
var _t = function(e, t, a, s) {
  var c;
  t[0] = 0;
  for (var d = 1; d < t.length; d++) {
    var h = t[d++], f = t[d] ? (t[0] |= h ? 1 : 2, a[t[d++]]) : t[++d];
    h === 3 ? s[0] = f : h === 4 ? s[1] = Object.assign(s[1] || {}, f) : h === 5 ? (s[1] = s[1] || {})[t[++d]] = f : h === 6 ? s[1][t[++d]] += f + "" : h ? (c = e.apply(f, _t(e, f, a, ["", null])), s.push(c), f[0] ? t[0] |= 2 : (t[d - 2] = 0, t[d] = c)) : s.push(f);
  }
  return s;
}, Ue = /* @__PURE__ */ new Map();
function ts(e) {
  var t = Ue.get(this);
  return t || (t = /* @__PURE__ */ new Map(), Ue.set(this, t)), (t = _t(this, t.get(e) || (t.set(e, t = (function(a) {
    for (var s, c, d = 1, h = "", f = "", _ = [0], A = function(R) {
      d === 1 && (R || (h = h.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? _.push(0, R, h) : d === 3 && (R || h) ? (_.push(3, R, h), d = 2) : d === 2 && h === "..." && R ? _.push(4, R, 0) : d === 2 && h && !R ? _.push(5, 0, !0, h) : d >= 5 && ((h || !R && d === 5) && (_.push(d, 0, h, c), d = 6), R && (_.push(d, R, 0, c), d = 6)), h = "";
    }, O = 0; O < a.length; O++) {
      O && (d === 1 && A(), A(O));
      for (var U = 0; U < a[O].length; U++) s = a[O][U], d === 1 ? s === "<" ? (A(), _ = [_], d = 3) : h += s : d === 4 ? h === "--" && s === ">" ? (d = 1, h = "") : h = s + h[0] : f ? s === f ? f = "" : h += s : s === '"' || s === "'" ? f = s : s === ">" ? (A(), d = 1) : d && (s === "=" ? (d = 5, c = h, h = "") : s === "/" && (d < 5 || a[O][U + 1] === ">") ? (A(), d === 3 && (_ = _[0]), d = _, (_ = _[0]).push(2, 0, d), d = 0) : s === " " || s === "	" || s === `
` || s === "\r" ? (A(), d = 2) : h += s), d === 3 && h === "!--" && (d = 4, _ = _[0]);
    }
    return A(), _;
  })(e)), t), arguments, [])).length > 1 ? t : t[0];
}
ts.bind(V);
let Ie = [];
function x(...e) {
  Ie.push(e.map((t) => JSON.stringify(t)).join(" "));
}
function us() {
  return Ie;
}
function as() {
  Ie = [];
}
function se(e) {
  const { type: t, props: a } = e;
  return { type: t, props: a };
}
function Ce(e) {
  const t = {};
  if (e.nodeName === "#comment")
    return e.data;
  if (e.nodeName === "#text")
    return e.value;
  const { childNodes: a, attrs: s, tagName: c } = e;
  for (const d of s || [])
    t[d.name] = d.value;
  try {
    return se(
      V(c, t, ...(a || []).map((d) => Ce(d)))
    );
  } catch (d) {
    return se(V("div", { class: "parseNode" }, d.stack));
  }
}
function ss(e) {
  try {
    const t = Ja(e.outerHTML);
    return Ce(t.childNodes[0]);
  } catch (t) {
    return se(V("div", { class: "parseDocument" }, t.stack));
  }
}
function rs(e) {
  try {
    const t = Za(e.outerHTML);
    return Ce(t);
  } catch (t) {
    return se(V("div", { class: "parseFragmentWrapper" }, t.stack));
  }
}
async function is() {
  let e = 0, t, a;
  const s = new Promise((h, f) => {
    t = h, a = f;
  }), c = setTimeout(
    () => a(new Error("Timeout waiting for body")),
    1e4
  );
  function d() {
    document.body && t();
  }
  e = requestAnimationFrame(d), await s, cancelAnimationFrame(e), clearTimeout(c);
}
let ye = 0;
function we(e) {
  if (typeof e.querySelectorAll != "function") {
    x(
      "assignRef: elem has no querySelectorAll",
      e.nodeType || e.nodeName || e.textContent || Object.keys(e)
    );
    return;
  }
  e.hasAttribute("data-wdio-ref") || e.setAttribute("data-wdio-ref", `${++ye}`), Array.from(e.querySelectorAll("*")).forEach((t) => {
    t.setAttribute("data-wdio-ref", `${++ye}`);
  });
}
function Z(e) {
  return !e || !e.getAttribute ? null : e.getAttribute("data-wdio-ref");
}
const ns = ["log", "info", "warn", "error"];
class cs {
  #e = [];
  constructor() {
    ns.forEach(this.#t.bind(this));
  }
  getArtifacts() {
    return this.#e;
  }
  clear() {
    this.#e = [];
  }
  #t(t) {
    const a = console[t];
    console[t] = (...s) => (this.#e.push({
      timestamp: Date.now(),
      type: t,
      args: s
    }), a(...s));
  }
}
class os {
  #e = {
    url: window.location.href,
    viewport: window.visualViewport
  };
  #t = [];
  #u = [];
  #a = new cs();
  captureError(t) {
    const a = t.stack || t.message;
    this.#t.push(a);
  }
  captureMutation(t) {
    this.#u.push(...t);
  }
  reset() {
    this.#t = [], this.#u = [], this.#a.clear(), as();
  }
  getMetadata() {
    return this.#e;
  }
  getTraceData() {
    const t = {
      errors: this.#t,
      mutations: this.#u,
      consoleLogs: this.#a.getArtifacts(),
      traceLogs: us(),
      metadata: this.getMetadata()
    };
    return this.reset(), t;
  }
}
const $ = window.wdioTraceCollector = new os();
try {
  x("waiting for body to render"), await is(), x("body rendered"), we(document.documentElement), x("applied wdio ref ids");
  const e = Date.now();
  $.captureMutation([
    {
      type: "childList",
      url: document.location.href,
      timestamp: e,
      addedNodes: [ss(document.documentElement)],
      removedNodes: []
    }
  ]), x("added initial page structure");
  const t = { attributes: !0, childList: !0, subtree: !0 };
  new MutationObserver((s) => {
    const c = Date.now(), d = s.filter((h) => h.attributeName !== "data-wdio-ref");
    x(`observed ${d.length} mutations`);
    try {
      $.captureMutation(
        d.map(
          ({
            target: h,
            addedNodes: f,
            removedNodes: _,
            type: A,
            attributeName: O,
            attributeNamespace: U,
            previousSibling: R,
            nextSibling: Oe,
            oldValue: mt
          }) => {
            const bt = Array.from(f).map((j) => (we(j), rs(j))), At = Array.from(_).map((j) => Z(j)), Nt = Z(h), It = R ? Z(R) : null, Ct = Oe ? Z(Oe) : null;
            let Se;
            A === "attributes" && (Se = h.getAttribute(O) || "");
            let Le;
            return A === "characterData" && (Le = h.textContent || ""), x(`added mutation: ${A}`), {
              type: A,
              attributeName: O,
              attributeNamespace: U,
              oldValue: mt,
              addedNodes: bt,
              target: Nt,
              removedNodes: At,
              previousSibling: It,
              nextSibling: Ct,
              timestamp: c,
              attributeValue: Se,
              newTextContent: Le
            };
          }
        )
      );
    } catch (h) {
      $.captureError(h);
    }
  }).observe(document.body, t);
} catch (e) {
  $.captureError(e);
}
x("Finished program");
