import { remote as a } from "webdriverio";
import { start as c } from "@wdio/devtools-backend";
import r from "@wdio/logger";
const S = [
  "url",
  "navigateTo",
  "elementClick"
], E = {
  browserName: "chrome",
  "goog:chromeOptions": {
    // production:
    args: ["--window-size=1600,1200"]
    // development:
    // args: ['--window-size=1600,1200', '--auto-open-devtools-for-tabs']
  }
}, w = [
  "emit",
  "browsingContextLocateNodes",
  "browsingContextNavigate",
  "waitUntil",
  "getTitle",
  "getUrl",
  "getWindowSize",
  "setWindowSize",
  "deleteSession",
  "findElementFromShadowRoot",
  "findElementsFromShadowRoot",
  "waitForExist",
  "browsingContextGetTree",
  "scriptCallFunction",
  "getElement",
  "execute",
  "findElement",
  "getElementText",
  "getElementShadowRoot"
], T = [
  "url",
  "back",
  "forward",
  "refresh",
  "switchFrame",
  "newWindow",
  "createWindow",
  "closeWindow"
], h = /\/(test|spec|features|pageobjects|@wdio\/expect-webdriverio)\//i, m = [
  "typescript",
  "jsx",
  "decorators-legacy",
  "classProperties",
  "dynamicImport"
], A = ["it", "test", "specify", "fit", "xit"], R = ["describe", "context", "suite"], f = [
  "Given",
  "When",
  "Then",
  "And",
  "But",
  "defineStep"
], N = /\.(?:steps?)\.[cm]?[jt]sx?$/i, g = /(?:^|\/)(?:step[-_]?definitions|steps)\/.+\.[cm]?[jt]sx?$/i, u = /\.(?:test|spec)\.[cm]?[jt]sx?$/i, C = /\.feature$/i, P = /\.(?:[cm]?js|[cm]?ts)x?$/, F = /^\s*(Feature|Scenario(?: Outline)?):\s*(.+)\s*$/i, I = /\b(Given|When|Then|And|But)\s*\(\s*(\/(?:\\.|[^/\\])+\/[gimsuy]*)/, b = /\b(Given|When|Then|And|But)\s*\(\s*(['`])([^'`\\]*(?:\\.[^'`\\]*)*)\2/, v = [
  "step-definitions",
  "step_definitions",
  "steps"
], L = 6, x = 5, n = r("@wdio/devtools-service:Launcher");
class D {
  #e;
  #t;
  constructor(t) {
    this.#e = t;
  }
  async onPrepare(t, o) {
    try {
      const { server: e } = await c({
        port: this.#e.port,
        hostname: this.#e.hostname
      }), i = e.address(), s = i && typeof i == "object" ? i.port : void 0;
      if (!s)
        return console.log(`Failed to start server on port ${s}`);
      this.#s(o, { port: s }), this.#t = await a({
        automationProtocol: "devtools",
        capabilities: {
          ...E,
          ...this.#e.devtoolsCapabilities
        }
      }), await this.#t.url(`http://localhost:${s}`);
    } catch (e) {
      console.error(e);
    }
  }
  async onComplete() {
    if (this.#t) {
      for (r.setLevel("devtools", "warn"), n.info("Please close the browser window to finish..."); ; )
        try {
          await this.#t.getTitle(), await new Promise((t) => setTimeout(t, 1e3));
        } catch {
          n.info("Browser window closed, stopping DevTools app");
          break;
        }
      try {
        await this.#t.deleteSession();
      } catch (t) {
        n.warn("Session already closed or could not be deleted:", t.message);
      }
    }
  }
  #s(t, o) {
    if (Array.isArray(t))
      for (const e of t)
        e["wdio:devtoolsOptions"] = {
          port: o.port,
          hostname: "localhost"
        };
  }
}
export {
  T as C,
  D,
  C as F,
  w as I,
  S as P,
  R as S,
  A as T,
  F as a,
  m as b,
  L as c,
  v as d,
  f as e,
  N as f,
  g,
  u as h,
  x as i,
  P as j,
  I as k,
  b as l,
  h as m
};
