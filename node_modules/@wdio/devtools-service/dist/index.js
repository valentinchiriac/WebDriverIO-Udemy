import T from "node:fs/promises";
import h from "node:path";
import j from "@wdio/logger";
import { SevereServiceError as _ } from "webdriverio";
import L from "node:url";
import { WebSocket as v } from "ws";
import { parse as k } from "stack-trace";
import { resolve as J } from "import-meta-resolve";
import { P as K, F as x, a as V, b as $, S as I, T as P, c as z, d as O, e as Q, f as Y, g as Z, h as ee, i as te, j as ie, k as ne, l as se, D as re, m as oe, I as ce, C as ae } from "./launcher-ByD8xdQE.js";
import le from "@wdio/reporter";
import d from "fs";
import { createRequire as ue } from "node:module";
import { parse as U } from "@babel/parser";
import * as R from "@babel/traverse";
import { TraceType as M } from "./types.js";
const m = j("@wdio/devtools-service:SessionCapturer");
class F {
  constructor(e = {}) {
    this.#e = !1, this.commandsLog = [], this.sources = /* @__PURE__ */ new Map(), this.mutations = [], this.traceLogs = [], this.consoleLogs = [];
    const { port: n, hostname: s } = e;
    s && n && (this.#i = new v(`ws://${s}:${n}/worker`), this.#i.on(
      "error",
      (i) => m.error(
        `Couldn't connect to devtools backend: ${i.message}`
      )
    ));
  }
  #i;
  #e;
  get isReportingUpstream() {
    return !!this.#i && this.#i?.readyState === v.OPEN;
  }
  /**
   * after command hook
   *
   * Used to
   *  - capture command logs
   *  - capture trace data from the application under test
   *
   * @param {string} command command name
   * @param {Array} args command arguments
   * @param {object} result command result
   * @param {Error} error command error
   */
  async afterCommand(e, n, s, i, o, c) {
    const a = k(new Error("")).filter((p) => !!p.getFileName()).map(
      (p) => [
        p.getFileName(),
        p.getLineNumber(),
        p.getColumnNumber()
      ].join(":")
    ).filter(
      (p) => !p.includes("/node_modules/") && !p.includes("<anonymous>)") && !p.includes("node:internal") && !p.includes("/dist/")
    ).shift() || "", r = a.startsWith("file://") ? L.fileURLToPath(a) : a, u = r.split(":")[0], l = await T.access(u).then(
      () => !0,
      () => !1
    );
    if (a && !this.sources.has(a) && l) {
      const p = await T.readFile(u, "utf-8");
      this.sources.set(u, p.toString()), this.sendUpstream("sources", { [u]: p.toString() });
    }
    const f = {
      command: n,
      args: s,
      result: i,
      error: o,
      timestamp: Date.now(),
      callSource: c ?? r
    };
    try {
      f.screenshot = await e.takeScreenshot();
    } catch (p) {
      m.warn(`failed to capture screenshot: ${p.message}`);
    }
    this.commandsLog.push(f), this.sendUpstream("commands", [f]), K.includes(n) && await this.#t(e);
  }
  async injectScript(e) {
    if (this.#e) {
      m.info("Script already injected, skipping");
      return;
    }
    if (!e.isBidi)
      throw new _(
        `Can not set up devtools for session with id "${e.sessionId}" because it doesn't support WebDriver Bidi`
      );
    this.#e = !0, m.info("Injecting devtools script...");
    const n = await J("@wdio/devtools-script", import.meta.url), i = `async () => { ${(await T.readFile(L.fileURLToPath(n))).toString()} }`;
    await e.scriptAddPreloadScript({
      functionDeclaration: i
    }), m.info("✓ Script injected successfully");
  }
  async #t(e) {
    if (!this.#e) {
      m.warn("Script not injected, skipping trace capture");
      return;
    }
    try {
      if (!await e.execute(
        () => typeof window.wdioTraceCollector < "u"
      )) {
        m.warn(
          "wdioTraceCollector not loaded yet - page loaded before preload script took effect"
        );
        return;
      }
      const { mutations: s, traceLogs: i, consoleLogs: o, metadata: c } = await e.execute(() => window.wdioTraceCollector.getTraceData());
      this.metadata = c, Array.isArray(s) && (this.mutations.push(...s), this.sendUpstream("mutations", s)), Array.isArray(i) && (this.traceLogs.push(...i), this.sendUpstream("logs", i)), Array.isArray(o) && (this.consoleLogs.push(...o), this.sendUpstream("consoleLogs", o)), this.sendUpstream("metadata", c), m.info(`✓ Sent metadata upstream, WS state: ${this.#i?.readyState}`);
    } catch (n) {
      m.error(`Failed to capture trace: ${n.message}`);
    }
  }
  sendUpstream(e, n) {
    !this.#i || this.#i.readyState !== v.OPEN || this.#i.send(JSON.stringify({ scope: e, data: n }));
  }
}
const B = ue(import.meta.url), fe = B("stack-trace"), y = /* @__PURE__ */ new Map();
let w;
try {
  const t = B("@cucumber/cucumber-expressions");
  w = {
    CucumberExpression: t.CucumberExpression,
    ParameterTypeRegistry: t.ParameterTypeRegistry
  };
} catch {
}
const W = R.default ?? R;
let C;
function A(t) {
  C = t;
}
function b(t) {
  const e = t;
  return e.parent ? b(e.parent) : t;
}
function N(t) {
  if (t) {
    if (t.type === "Identifier")
      return t.name;
    if (t.type === "MemberExpression") {
      const e = t.object;
      return e && e.type === "Identifier" ? e.name : void 0;
    }
  }
}
function G(t) {
  if (!d.existsSync(t))
    return [];
  const e = d.readFileSync(t, "utf-8"), n = U(e, {
    sourceType: "module",
    plugins: $,
    errorRecovery: !0,
    allowReturnOutsideFunction: !0
  }), s = [], i = [], o = (r) => !!r && I.includes(r) || r === "Feature", c = (r) => !!r && P.includes(r), a = (r) => {
    if (r) {
      if (r.type === "StringLiteral")
        return r.value;
      if (r.type === "TemplateLiteral" && r.expressions.length === 0)
        return r.quasis.map((u) => u.value.cooked).join("");
    }
  };
  return W(n, {
    enter(r) {
      if (!r.isCallExpression())
        return;
      const u = r.node.callee, l = N(u);
      if (l) {
        if (o(l)) {
          const f = a(r.node.arguments?.[0]);
          f && (s.push({
            type: "suite",
            name: f,
            titlePath: [...i, f],
            line: r.node.loc?.start.line,
            column: r.node.loc?.start.column
          }), i.push(f));
        } else if (c(l)) {
          const f = a(r.node.arguments?.[0]);
          f && s.push({
            type: "test",
            name: f,
            titlePath: [...i, f],
            line: r.node.loc?.start.line,
            column: r.node.loc?.start.column
          });
        }
      }
    },
    exit(r) {
      if (!r.isCallExpression())
        return;
      const u = r.node.callee, l = N(u);
      if (!l || !o(l))
        return;
      const f = (() => {
        const p = r.node.arguments?.[0];
        if (p?.type === "StringLiteral")
          return p.value;
        if (p?.type === "TemplateLiteral" && p.expressions.length === 0)
          return p.quasis.map((g) => g.value.cooked).join("");
      })();
      f && i[i.length - 1] === f && i.pop();
    }
  }), s;
}
function pe() {
  const t = fe.parse(new Error()), e = (o) => {
    const c = t.find((a) => {
      const r = a.getFileName();
      return !!r && !r.includes("node_modules") && o(a);
    });
    return c ? {
      file: c.getFileName(),
      line: c.getLineNumber(),
      column: c.getColumnNumber()
    } : null;
  }, n = e((o) => {
    const c = o.getFileName();
    return Y.test(c) || Z.test(c);
  });
  if (n)
    return n;
  const s = e((o) => ee.test(o.getFileName()));
  if (s)
    return s;
  const i = e((o) => x.test(o.getFileName()));
  return i || null;
}
function de(t) {
  let e = t;
  for (let n = 0; n < z; n++) {
    for (const i of O) {
      const o = h.join(e, i);
      if (d.existsSync(o) && d.statSync(o).isDirectory())
        return o;
    }
    const s = h.dirname(e);
    if (s === e)
      break;
    e = s;
  }
}
let S;
function me() {
  if (S && d.existsSync(S))
    return S;
  const e = [{ dir: process.cwd(), depth: 0 }], n = te;
  for (; e.length; ) {
    const { dir: s, depth: i } = e.shift();
    if (i > n)
      continue;
    const o = h.join(s, "features");
    if (d.existsSync(o) && d.statSync(o).isDirectory())
      for (const c of O) {
        const a = h.join(o, c);
        if (d.existsSync(a) && d.statSync(a).isDirectory())
          return S = a, a;
      }
    for (const c of d.readdirSync(s)) {
      if (c.startsWith("."))
        continue;
      const a = h.join(s, c);
      let r;
      try {
        r = d.statSync(a);
      } catch {
        continue;
      }
      r.isDirectory() && !a.includes("node_modules") && e.push({ dir: a, depth: i + 1 });
    }
  }
}
function q(t) {
  const e = [];
  for (const n of d.readdirSync(t)) {
    const s = h.join(t, n);
    d.statSync(s).isDirectory() ? e.push(...q(s)) : ie.test(n) && e.push(s);
  }
  return e;
}
function he(t) {
  const e = [], s = d.readFileSync(t, "utf-8").split(/\r?\n/);
  for (let i = 0; i < s.length; i++) {
    const o = s[i], c = o.match(ne);
    if (c) {
      const r = c[2], u = r.lastIndexOf("/"), l = r.slice(1, u), f = r.slice(u + 1);
      try {
        e.push({
          kind: "regex",
          regex: new RegExp(l, f),
          file: t,
          line: i + 1,
          column: c.index ?? 0
        });
        continue;
      } catch {
      }
    }
    const a = o.match(se);
    if (a) {
      const r = a[1], u = a[3];
      e.push({
        kind: "string",
        keyword: r,
        text: u,
        file: t,
        line: i + 1,
        column: a.index ?? 0
      });
    }
  }
  return e;
}
const D = /* @__PURE__ */ new Map();
function ge(t) {
  const e = D.get(t);
  if (e)
    return e;
  const n = q(t), s = [];
  for (const i of n) {
    let o = 0;
    try {
      const c = d.readFileSync(i, "utf-8"), a = U(c, {
        sourceType: "module",
        plugins: $,
        errorRecovery: !0
      });
      W(a, {
        CallExpression(r) {
          const u = r.node.callee;
          let l;
          if (u?.type === "Identifier")
            l = u.name;
          else if (u?.type === "MemberExpression") {
            const g = u.property;
            g?.type === "Identifier" && (l = g.name);
          }
          if (!l || !Q.includes(l))
            return;
          const f = r.node.arguments?.[0], p = {
            file: i,
            line: r.node.loc?.start.line ?? 1,
            column: r.node.loc?.start.column ?? 0
          };
          if (f?.type === "RegExpLiteral")
            s.push({
              kind: "regex",
              regex: new RegExp(f.pattern, f.flags ?? ""),
              ...p
            }), o++;
          else if (f?.type === "StringLiteral") {
            if (w && f.value.includes("{")) {
              const g = new w.CucumberExpression(
                f.value,
                new w.ParameterTypeRegistry()
              );
              s.push({ kind: "expression", expr: g, ...p });
            } else
              s.push({
                kind: "string",
                keyword: l,
                text: f.value,
                ...p
              });
            o++;
          }
        }
      });
    } catch {
    }
    if (o === 0) {
      const c = he(i);
      c.length && s.push(...c);
    }
  }
  return D.set(t, s), s;
}
function ye(t, e) {
  const n = e ? h.extname(e) ? h.dirname(e) : e : void 0;
  let s = n ? de(n) : void 0;
  if (s || (s = me()), !s)
    return;
  const i = ge(s), o = String(t ?? "").trim(), c = o.replace(/^(Given|When|Then|And|But)\s+/i, "").trim(), a = i.find(
    (l) => l.kind === "string" && (c.localeCompare(l.text, "en", { sensitivity: "base" }) === 0 || o.localeCompare(`${l.keyword} ${l.text}`, "en", {
      sensitivity: "base"
    }) === 0)
  );
  if (a)
    return { file: a.file, line: a.line, column: a.column };
  const r = i.find(
    (l) => l.kind === "expression" && (() => {
      try {
        return !!l.expr.match(c) || !!l.expr.match(o);
      } catch {
        return !1;
      }
    })()
  );
  if (r)
    return { file: r.file, line: r.line, column: r.column };
  const u = i.find(
    (l) => l.kind === "regex" && (l.regex.test(c) || l.regex.test(o))
  );
  if (u)
    return { file: u.file, line: u.line, column: u.column };
}
function Se(t) {
  return String(t || "").replace(/^\d+:\s*/, "").replace(/\s+/g, " ").trim();
}
function X(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function H(t, e) {
  let n = 1, s = 1;
  for (let i = 0; i < e && i < t.length; i++)
    t.charCodeAt(i) === 10 ? (n++, s = 1) : s++;
  return { line: n, column: s };
}
function Ee(t, e) {
  try {
    const n = d.readFileSync(t, "utf-8"), s = `(['"\`])${X(e)}\\1`, i = String.raw`\b(?:${P.join("|")})\s*\(\s*${s}`, c = new RegExp(i).exec(n);
    if (c && typeof c.index == "number") {
      const { line: a, column: r } = H(n, c.index);
      return { file: t, line: a, column: r };
    }
  } catch {
  }
}
function Te(t, e) {
  try {
    const n = d.readFileSync(t, "utf-8"), s = `(['"\`])${X(e)}\\1`, i = String.raw`\b(?:${I.join("|")})\s*\(\s*${s}`, c = new RegExp(i).exec(n);
    if (c && typeof c.index == "number") {
      const { line: a, column: r } = H(n, c.index);
      return { file: t, line: a, column: r };
    }
  } catch {
  }
}
function we(t, e) {
  const n = String(t?.title ?? "").trim(), s = Se(t?.fullTitle), i = (Array.isArray(t.specs) ? t.specs[0] : void 0) || t.file || t.specFile || e || C;
  if (/^(Given|When|Then|And|But)\b/i.test(n)) {
    const a = ye(
      n,
      x.test(String(i)) ? i : void 0
    );
    if (a) {
      Object.assign(t, a);
      return;
    }
  }
  const o = t.file || (Array.isArray(t.specs) ? t.specs[0] : void 0) || t.specFile || e || C;
  if (o && !x.test(o)) {
    if (!y.has(o))
      try {
        y.set(o, G(o));
      } catch {
      }
    const a = y.get(o);
    if (a?.length) {
      const u = a.find(
        (l) => l.type === "test" && l.name === n && s.includes(l.titlePath.join(" "))
      ) || a.find((l) => l.type === "test" && l.name === n);
      if (u) {
        Object.assign(t, {
          file: o,
          line: u.line,
          column: u.column
        });
        return;
      }
    }
    const r = Ee(o, n);
    if (r) {
      Object.assign(t, r);
      return;
    }
  }
  const c = pe();
  c && Object.assign(t, c);
}
function xe(t, e, n = []) {
  const s = String(t?.title ?? "").trim(), i = t.file || e || C;
  if (!s || !i)
    return;
  if (x.test(i)) {
    try {
      const c = d.readFileSync(i, "utf-8").split(/\r?\n/), a = (u) => u.trim().replace(/\s+/g, " "), r = a(s);
      for (let u = 0; u < c.length; u++) {
        const l = c[u].match(V);
        if (l && a(l[2]) === r) {
          Object.assign(t, { file: i, line: u + 1, column: 1 });
          return;
        }
      }
    } catch {
    }
    return;
  }
  try {
    y.has(i) || y.set(i, G(i));
    const c = y.get(i);
    if (c?.length) {
      const a = c.find(
        (r) => r.type === "suite" && Array.isArray(r.titlePath) && r.titlePath.length === n.length && r.titlePath.every((u, l) => u === n[l])
      ) || c.find((r) => r.type === "suite" && r.titlePath.at(-1) === s);
      if (a?.line) {
        Object.assign(t, {
          file: i,
          line: a.line,
          column: a.column
        });
        return;
      }
    }
  } catch {
  }
  const o = Te(i, s);
  o && Object.assign(t, o);
}
class Ce extends le {
  #i;
  #e;
  #t = [];
  constructor(e, n) {
    super(e), this.#i = n;
  }
  onSuiteStart(e) {
    super.onSuiteStart(e), this.#e = e.file, A(e.file), e.title && this.#t.push(e.title), xe(e, this.#e, this.#t), e.file && e.line !== null && (e.callSource = `${e.file}:${e.line}`), this.#n();
  }
  onTestStart(e) {
    we(e, this.#e), e.file && e.line !== null && (e.callSource = `${e.file}:${e.line}`), super.onTestStart(e), this.#n();
  }
  onTestEnd(e) {
    super.onTestEnd(e), this.#n();
  }
  onSuiteEnd(e) {
    super.onSuiteEnd(e), e.title && this.#t[this.#t.length - 1] === e.title && this.#t.pop(), this.#t.length === 0 && (this.#e = void 0, A(void 0)), this.#n();
  }
  #n() {
    if (!this.suites)
      return;
    const e = [];
    for (const [n, s] of Object.entries(this.suites))
      s && e.push({ [n]: s });
    e.length > 0 && this.#i(e);
  }
  get report() {
    return this.suites;
  }
}
const Ue = re, E = j("@wdio/devtools-service");
function Me(t) {
  let e = !1;
  const n = new ve();
  return n.captureType = M.Standalone, n.beforeSession(t, t), t.beforeCommand = Array.isArray(t.beforeCommand) ? t.beforeCommand : t.beforeCommand ? [t.beforeCommand] : [], t.beforeCommand.push(async function(i) {
    e || (e = !0, n.before(
      this.capabilities,
      [],
      this
    )), i === "deleteSession" && await n.after();
  }, n.beforeCommand.bind(n)), t.afterCommand = Array.isArray(t.afterCommand) ? t.afterCommand : t.afterCommand ? [t.afterCommand] : [], t.afterCommand.push(n.afterCommand.bind(n)), t;
}
class ve {
  constructor() {
    this.#i = [], this.#e = new F(), this.#n = [], this.#r = null, this.captureType = M.Testrunner, this.#s = !1;
  }
  #i;
  #e;
  #t;
  #n;
  #r;
  #s;
  async before(e, n, s) {
    this.#t = s;
    const i = e;
    this.#e = new F(
      i["wdio:devtoolsOptions"]
    );
    try {
      await this.#o(s);
    } catch (o) {
      E.error(
        `Failed to inject script at session start: ${o.message}`
      );
    }
    s.execute(() => window.visualViewport).then(
      (o) => this.#e.sendUpstream("metadata", {
        viewport: o || void 0,
        type: this.captureType,
        options: s.options,
        capabilities: s.capabilities
      })
    );
  }
  // The method signature is corrected to use W3CCapabilities
  beforeSession(e, n) {
    if (!("browserName" in n) && !("platformName" in n))
      throw new _(
        "The DevTools hook does not support multiremote yet"
      );
    if ("reporters" in e) {
      const i = this;
      e.reporters = [
        ...e.reporters || [],
        /**
         * class wrapper to make sure we can access the reporter instance
         */
        class extends Ce {
          constructor(c) {
            super(
              c,
              (a) => i.#e.sendUpstream("suites", a)
            ), i.#i.push(this);
          }
        }
      ];
    }
  }
  /**
   * Hook for Cucumber framework.
   * beforeScenario is triggered at the beginning of every worker session, therefore
   * we can use it to reset the command stack and last command signature
   */
  beforeScenario() {
    this.resetStack();
  }
  /**
   * Hook for Mocha/Jasmine frameworks.
   * It does the exact same thing as beforeScenario.
   */
  beforeTest() {
    this.resetStack();
  }
  resetStack() {
    this.#r = null, this.#n = [];
  }
  async beforeCommand(e, n) {
    if (!this.#t)
      return;
    e === "url" && this.#e.sendUpstream("metadata", { url: n[0] }), Error.stackTraceLimit = 20;
    const i = k(new Error("")).reverse().find((o) => {
      const c = o.getFileName();
      return c && oe.test(c);
    });
    if (i && this.#n.length === 0 && !ce.includes(e)) {
      const o = i.getFileName() ?? void 0;
      let c = o;
      if (o?.startsWith("file://"))
        try {
          const f = new URL(o);
          c = decodeURIComponent(f.pathname);
        } catch {
          c = o;
        }
      c?.includes("?") && (c = c.split("?")[0]);
      const a = i.getLineNumber() ?? void 0, r = i.getColumnNumber() ?? void 0, u = c !== void 0 ? `${c}:${a ?? 0}:${r ?? 0}` : void 0, l = JSON.stringify({
        command: e,
        args: n,
        src: u
      });
      this.#r !== l && (this.#n.push({ command: e, callSource: u }), this.#r = l);
    }
  }
  afterCommand(e, n, s, i) {
    if (this.#s)
      return;
    const o = this.#n[this.#n.length - 1];
    if (o?.command === e && (this.#n.pop(), this.#t))
      return this.#e.afterCommand(
        this.#t,
        e,
        n,
        s,
        i,
        o.callSource
      );
    ae.includes(e) && this.#c(`context-change:${e}`);
  }
  /**
   * after hook is triggered at the end of every worker session, therefore
   * we can use it to write all trace information to a file
   */
  async after() {
    if (!this.#t)
      return;
    const e = this.#t.options.outputDir || process.cwd(), { ...n } = this.#t.options, s = {
      mutations: this.#e.mutations,
      logs: this.#e.traceLogs,
      consoleLogs: this.#e.consoleLogs,
      metadata: {
        type: this.captureType,
        ...this.#e.metadata,
        options: n,
        capabilities: this.#t.capabilities
      },
      commands: this.#e.commandsLog,
      sources: Object.fromEntries(this.#e.sources),
      suites: this.#i.map((o) => o.report)
    }, i = h.join(
      e,
      `wdio-trace-${this.#t.sessionId}.json`
    );
    await T.writeFile(i, JSON.stringify(s)), E.info(`DevTools trace saved to ${i}`);
  }
  /**
   * Synchronous injection that blocks until complete
   */
  async #o(e) {
    if (!e.isBidi)
      throw new _(
        `Can not set up devtools for session with id "${e.sessionId}" because it doesn't support WebDriver Bidi`
      );
    await this.#e.injectScript(b(e)), E.info("✓ Devtools preload script active");
  }
  async #c(e) {
    if (!(!this.#t || this.#s))
      try {
        if (this.#s = !0, await this.#t.execute(() => !!window.__WDIO_DEVTOOLS_MARK))
          return;
        await this.#e.injectScript(b(this.#t));
      } catch (n) {
        E.warn(`[inject] failed (reason=${e}): ${n.message}`);
      } finally {
        this.#s = !1;
      }
  }
}
export {
  M as TraceType,
  ve as default,
  Ue as launcher,
  Me as setupForDevtools
};
